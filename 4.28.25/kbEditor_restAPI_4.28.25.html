<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Knowledge Base Editor (.DOCX to .JS/Markdown) - vAPI</title>
  <!-- Font Awesome and Material Icons from CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <style>
    /* Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    body {
      background-color: #f5f8fa;
      color: #333;
      line-height: 1.6;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }
    /* Header */
    .headerArea {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background-color: #1e293b;
      color: #fff !important;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
    }
    .headerArea h1 {
      color: #fff;
      margin-bottom: 0.5rem;
      font-weight: 500 !important;
    }

    /* Main Navigation Tabs */
    .main-nav-tabs {
      display: flex;
      margin-top: 80px; /* Increased to ensure it's below fixed header */
      margin-bottom: 20px;
      border-bottom: 1px solid #ddd;
    }
    .main-nav-tab {
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      color: #6b7280;
      font-weight: 500;
    }
    .main-nav-tab.active {
      border-bottom-color: #3498db;
      color: #3498db;
      font-weight: 600;
    }
    .main-tab-content {
      display: none;
    }
    .main-tab-content.active {
      display: block;
    }

    /* Upload & Preview Areas */
    .app-container {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .upload-area, .preview-area {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 1.5rem;
    }
    .upload-area {
      text-align: center;
      display: flex;
    }
    .drop-zone {
      border: 2px dashed #3498db;
      border-radius: 5px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
      flex: 1 1 50%;
    }
    .drop-zone:hover, .drop-zone.active {
      border-color: #2980b9;
      background-color: #f0f7fc;
    }
    .drop-zone-text {
      font-size: 1.2rem;
      color: #3498db;
      margin-bottom: 1rem;
    }
    .btn {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 0.55rem 1.5rem;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: background-color 0.2s;
    }
    .btn:hover {
      background-color: #2980b9;
    }
    .btn:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }
    .btn-browser {
      background-color: #f8f9fa;
      color: #3498db;
      border: 1px solid #3498db;
    }
    .btn-browser:hover {
      background-color: #e9f5fe;
    }
    #fileInput {
      display: none;
    }
    .file-info {
      text-align: left;
      padding: 0.85rem;
      border-radius: 5px;
      transition: opacity 0.3s;
      flex: 1 1 50%;
      margin: auto 20px;
      opacity: 0; /* Start hidden */
    }
    .file-info.show {
      opacity: 1;
    }
    .export-options {
      background-color: white;
      padding: 0;
      float: right;
      display: inline-flex;
      margin-left: auto; /* Adjusted margin */
    }
    .form-group {
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center; /* Align items vertically */
    }
    .form-group label {
      display: block;
      font-weight: 600;
      color: #2c3e50;
      position: relative;
      margin-right: 8px; /* Increased spacing */
      white-space: nowrap; /* Prevent label wrapping */
    }
    .form-group input {
      width: auto; /* Adjust width */
      min-width: 200px; /* Set minimum width */
      padding: 0.75rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 1rem;
    }
    .alert {
      padding: 1rem;
      border-radius: 5px;
      margin-bottom: 1.5rem;
      opacity: 0;
      transition: opacity 0.3s ease-out, top 0.3s ease-out; /* Added transition */
      position: fixed; /* Keep alert visible */
      top: 70px; /* Adjusted initial position slightly below header */
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      min-width: 300px;
      text-align: center;
      max-width: 80%;
      pointer-events: none; /* Allow clicks through when hidden */
    }
    .alert-success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .alert-error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
     .alert-warning {
        background-color: #fff3cd;
        color: #856404;
        border: 1px solid #ffeeba;
     }
      .alert-info {
        background-color: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
      }
    .alert.show {
      opacity: 1;
      top: 90px; /* Move down when shown */
      pointer-events: auto; /* Allow interaction when shown */
    }
    .preview-content {
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 5px;
      font-size: 0.9rem;
      line-height: 1.5;
      min-height: 200px;
      max-height: 60vh; /* Limit max height */
      overflow-y: auto;
      border: 1px solid #ddd; /* Added border */
    }
    /* Rich Text Editor */
    #editableContent {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      white-space: normal;
      min-height: 300px;
      border: 1px solid #ddd;
      outline: none;
      padding: 1.5rem; /* Consistent padding */
      background-color: white;
      max-height: 60vh; /* Limit max height */
      overflow-y: auto;
    }
    .editor-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      padding: 0.5rem;
      background-color: #f1f3f4;
      border: 1px solid #ddd;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
    }
    .editor-toolbar button {
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 0.3rem 0.6rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .editor-toolbar button:hover {
      background-color: #e9ecef;
    }
    .editor-toolbar button.active {
      background-color: #e2f0fd;
      border-color: #3498db;
    }
    .js-editor {
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      background-color: #2d2d2d;
      color: #f8f8f2;
      border: 1px solid #444;
      padding: 1.5rem !important; /* Consistent padding */
    }
    .js-editor-toolbar, .markdown-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background-color: #333;
      border: 1px solid #444;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
    }
    .js-format-btn, .copy-markdown-btn {
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .js-format-btn:hover, .copy-markdown-btn:hover {
      background-color: #45a049;
    }
    /* Toggle Switch */
    .editor-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #ddd;
      font-size: 0.9rem;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
    }
    input:checked + .slider {
      background-color: #3498db;
    }
    input:focus + .slider {
      box-shadow: 0 0 1px #3498db;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    .slider.round {
      border-radius: 24px;
    }
    .slider.round:before {
      border-radius: 50%;
    }
    /* Content Tabs */
    .content-tabs {
      display: flex;
      align-items: center; /* Align items vertically */
      margin-bottom: 1rem;
      border-bottom: 1px solid #ddd;
    }
    .content-tab {
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      white-space: nowrap; /* Prevent wrapping */
    }
    .content-tab.active {
      border-bottom-color: #3498db;
      color: #3498db;
      font-weight: 600;
    }
    .content-tab-panel {
      display: none;
    }
    .content-tab-panel.active {
      display: block;
    }
    button#exportBtn {
      position: relative;
      margin-left: 10px;
    }
    /* Additional styles for rich text content */
    #editableContent h1, #editableContent h2, #editableContent h3,
    #editableContent h4, #editableContent h5, #editableContent h6,
    #editableContent ul, #editableContent ol {
      padding-bottom: 10px;
      margin-bottom: 0.5em; /* Added margin */
    }
    #editableContent ul, #editableContent ol {
      padding-inline-start: 25px; /* Adjusted padding */
      margin-bottom: 1em; /* Added margin */
    }
    #editableContent li {
      padding-bottom: 4px; /* Increased padding */
      margin-bottom: 0.2em; /* Added margin */
    }
    /* Export type selector */
    .export-type-selector {
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .export-type-selector label {
      margin-right: 1rem;
      font-weight: 600;
    }
    /* Markdown preview styles */
    #markdownContent {
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      background-color: #f8f9fa;
      color: #333;
      border: 1px solid #ddd;
      padding: 1.5rem !important; /* Consistent padding */
      max-height: 60vh; /* Limit max height */
      overflow-y: auto;
    }
    .markdown-editor {
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      background-color: #f8f9fa;
      color: #333;
      border: 1px solid #ddd;
      padding: 1.5rem !important; /* Consistent padding */
      max-height: 60vh; /* Limit max height */
      overflow-y: auto;
    }
    /* File dropdown styles */
    #fileDropdown {
      margin: 1rem 0;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px solid #ddd;
      width: 100%;
      max-width: 400px;
    }

    /* Knowledge Base Manager Styles */
    .kb-manager-container {
      max-width: 1000px;
      margin: 0 auto;
      background-color: #f3f4f6;
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .action-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-bottom: 24px;
      align-items: flex-end; /* Align items to the bottom */
    }

    .dropdown-container {
      flex: 1;
      min-width: 200px; /* Reduced min-width */
    }

    .action-buttons {
      display: flex;
      align-items: flex-end;
      gap: 8px;
      margin-left: auto; /* Push buttons to the right */
    }

    /* Base button styles */
    .kb-manager-container button, .primary-button, .icon-button, .red-icon-button, .green-icon-button, .red-button {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid transparent;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        vertical-align: middle; /* Align icons better */
    }
    .kb-manager-container button:disabled, .primary-button:disabled {
      background-color: #9ca3af !important; /* Ensure override */
      cursor: not-allowed !important;
      opacity: 0.7 !important;
    }

    .primary-button {
      background-color: #4f46e5;
      color: white;
    }
    .primary-button:hover:not(:disabled) {
      background-color: #4338ca;
    }


    .icon-button {
      padding: 8px;
      background: none;
      color: #4f46e5;
      border: none;
    }
    .icon-button:hover:not(:disabled) {
      color: #4338ca;
      background-color: #e0e7ff; /* Light background on hover */
    }
    .icon-button svg { /* Ensure SVG scales with button */
        width: 20px;
        height: 20px;
    }

    .red-icon-button {
      padding: 6px; /* Slightly smaller padding */
      background: none;
      color: #ef4444;
      border: none;
    }
    .red-icon-button:hover:not(:disabled) {
      color: #dc2626;
      background-color: #fee2e2; /* Light red background on hover */
    }

    .green-icon-button {
      padding: 8px;
      background-color: #10b981;
      color: white;
    }
    .green-icon-button:hover:not(:disabled) {
      background-color: #059669;
    }

    .red-button {
      padding: 8px 12px; /* Ensure consistent padding */
      background-color: #ef4444;
      color: white;
    }
    .red-button:hover:not(:disabled) {
      background-color: #dc2626;
    }

    .section {
      background-color: white;
      padding: 16px;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
      margin-bottom: 24px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 10px; /* Add padding below header */
      border-bottom: 1px solid #e5e7eb; /* Separator line */
    }
     .section-header h2 {
        margin-bottom: 0; /* Remove default h2 margin */
     }
     .section-header .icon-button span {
         margin-left: 4px; /* Space between icon and text */
     }

    .category-form {
      margin-bottom: 16px;
      padding: 12px;
      background-color: #f9fafb;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }
    .category-form h3 {
        margin-bottom: 12px; /* Space below heading */
    }

    .input-group {
      display: flex;
      gap: 8px;
      align-items: center; /* Align items vertically */
    }

    .kb-manager-container input[type="text"] {
      flex: 1;
      padding: 8px 10px; /* Adjusted padding */
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14px;
    }

    .category-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 12px; /* Increased gap */
    }

    .category-item {
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      overflow: hidden;
      background-color: white; /* Ensure white background */
    }

    .category-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px; /* Consistent padding */
      background-color: #f9fafb;
      cursor: pointer;
      border-bottom: 1px solid #e5e7eb; /* Separator */
    }
    .category-header:hover {
        background-color: #f3f4f6; /* Slight hover effect */
    }
    .category-name {
        font-weight: 600; /* Make name bold */
        color: #1f2937;
    }

    .category-header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .chevron-icon {
        transition: transform 0.2s ease-in-out; /* Smooth transition */
        transform: rotate(0deg); /* Explicitly set initial state */
    }
    .category-item[data-collapsed="false"] .chevron-icon {
         transform: rotate(180deg); /* Rotate when open */
    }


    .category-content {
      padding: 16px; /* Consistent padding */
      background-color: white;
    }
    .category-item[data-collapsed="true"] .category-content {
        display: none; /* Use attribute selector for hiding */
    }


    .kb-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px; /* Increased margin */
    }
    .kb-header h4 {
        margin-bottom: 0; /* Remove default h4 margin */
        font-size: 14px;
        font-weight: 600;
        color: #374151;
    }
     .kb-header .icon-button span {
         margin-left: 4px; /* Space between icon and text */
     }

    .kb-form {
      margin-bottom: 16px; /* Increased margin */
      padding: 12px; /* Increased padding */
      background-color: #f9fafb;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }

    .kb-list {
      list-style: none;
      padding: 0;
      margin: 0; /* Remove default margin */
      display: flex;
      flex-direction: column;
      gap: 6px; /* Adjusted gap */
    }
    /* Target KB list within a category */
    .category-kb-list {
        margin-top: 8px; /* Add space above list in category */
        min-height: 30px; /* Minimum height for drop target visibility */
        padding: 8px; /* Padding for drop area */
        border: 1px dashed transparent; /* Placeholder for dragover */
        border-radius: 4px;
    }


    .kb-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px; /* Adjusted padding */
      font-size: 14px;
      background-color: #f9fafb;
      border: 1px solid #e5e7eb; /* Add border */
      border-radius: 6px;
    }
    /* Style for KB items in the 'All Knowledge Bases' list */
     #all-kb-list .kb-item {
        background-color: white; /* Different background */
     }


    /* Drag and drop styles */
    .kb-item.draggable {
      cursor: grab;
    }
    .kb-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
      background-color: #e0e7ff; /* Highlight while dragging */
      border-color: #a5b4fc;
    }
    .kb-item.draggable:hover {
      background-color: #eff6ff; /* Light blue hover */
      border-color: #bfdbfe;
    }
    .category-kb-list.dragover {
      background-color: #eff6ff; /* Highlight drop zone */
      border: 1px dashed #93c5fd;
    }

    .kb-badge {
      display: inline-block;
      padding: 2px 8px; /* Increased padding */
      background-color: #e5e7eb;
      border-radius: 12px; /* Pill shape */
      margin-right: 6px; /* Increased margin */
      font-size: 12px;
      font-weight: 500;
      color: #4b5563;
    }

    .icon {
      width: 20px;
      height: 20px;
    }
    .icon-sm {
      width: 18px; /* Adjusted size */
      height: 18px;
    }
    .icon-xs {
      width: 14px;
      height: 14px;
    }

    .hidden {
      display: none !important; /* Use important to override potential conflicts */
    }

    .text-gray {
      color: #6b7280;
      font-style: italic;
      text-align: center; /* Center placeholder text */
      padding: 16px; /* Add padding */
    }

    .kb-categories {
      margin-left: 12px; /* Increased margin */
      font-size: 12px;
      color: #6b7280;
      display: flex; /* Use flex for badges */
      flex-wrap: wrap;
      gap: 4px;
    }

    .drag-handle {
      cursor: grab;
      margin-right: 8px;
      color: #9ca3af;
      display: flex; /* Center icon */
      align-items: center;
    }
    .drag-handle svg { /* Ensure handle icon size */
        width: 16px;
        height: 16px;
    }


    .kb-info-container {
      display: flex;
      align-items: center;
      flex: 1;
      overflow: hidden; /* Prevent long names from breaking layout */
    }
    .kb-name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis; /* Add ellipsis for long names */
        margin-right: 8px; /* Space before categories/buttons */
    }

    .kb-manager-container h2 {
      font-size: 18px;
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 0; /* Reset margin, handled by section-header */
    }
    .kb-manager-container h3 {
      font-size: 16px; /* Slightly larger */
      font-weight: 600; /* Bolder */
      margin-bottom: 8px;
      color: #111827;
    }
     .kb-manager-container h4 {
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
     }

    .kb-manager-container select {
      width: 100%;
      padding: 10px;
      background-color: white;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      font-size: 14px; /* Consistent font size */
    }

    .kb-manager-container label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 6px; /* Increased margin */
      color: #374151; /* Darker label color */
    }

    /* Ensure icons inside buttons look good */
    .kb-manager-container button svg {
        vertical-align: middle;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="headerArea">
      <h1>Knowledge Base Editor (.DOCX to .JS/Markdown) - vAPI</h1>
    </div>

    <!-- Global Alert Box -->
    <div id="alertBox" class="alert"></div>

    <!-- Navigation Tabs -->
    <div class="main-nav-tabs">
      <div class="main-nav-tab active" data-main-tab="editor">Knowledge Base</div>
      <div class="main-nav-tab" data-main-tab="manager">Manage Knowledge Base</div>
    </div>

    <!-- Editor Section -->
    <div id="editor-tab" class="main-tab-content active">
      <select id="fileDropdown">
        <option value="">Select a kb_*.js file to edit</option>
      </select>
      <div class="app-container">
        <div class="upload-area">
          <div id="dropZone" class="drop-zone">
            <i class="fas fa-cloud-upload-alt" style="font-size:32px;"></i>
            <p class="drop-zone-text">Drag & Drop your DOCX file here</p>
            <button id="browseBtn" class="btn btn-browser">Browse Files</button>
            <input type="file" id="fileInput" accept=".docx" />
          </div>
          <div id="fileInfo" class="file-info">
            <h3>File Information</h3>
            <p id="fileName">No file selected</p>
            <p id="fileSize"></p>
          </div>
        </div>
        <div class="preview-area">
          <div class="content-tabs">
            <div class="content-tab active" data-content-tab="original">Original Content</div>
            <div class="content-tab" data-content-tab="markdown">Markdown</div>
            <div class="content-tab" data-content-tab="converted">Converted JS</div>
            <div class="export-options">
              <div class="form-group">
                <label for="outputFileName">Name:</label>
                <input type="text" id="outputFileName" placeholder="kb_knowledge-base.js" value="kb_knowledge-base.js" />
              </div>
              <button id="exportBtn" class="btn" disabled>Export / Save</button>
            </div>
          </div>
          <div id="originalContent" class="content-tab-panel active">
            <div class="editor-toolbar">
              <button type="button" data-command="bold" title="Bold"><b>B</b></button>
              <button type="button" data-command="italic" title="Italic"><i>I</i></button>
              <button type="button" data-command="underline" title="Underline"><u>U</u></button>
              <button type="button" data-command="formatBlock" data-value="H1" title="Heading 1">H1</button>
              <button type="button" data-command="formatBlock" data-value="H2" title="Heading 2">H2</button>
              <button type="button" data-command="formatBlock" data-value="H3" title="Heading 3">H3</button>
              <button type="button" data-command="formatBlock" data-value="H4" title="Heading 4">H4</button>
              <button type="button" data-command="formatBlock" data-value="H5" title="Heading 5">H5</button>
              <button type="button" data-command="formatBlock" data-value="H6" title="Heading 6">H6</button>
              <button type="button" data-command="insertUnorderedList" title="Bullet List">â€¢ List</button>
              <button type="button" data-command="insertOrderedList" title="Numbered List">1. List</button>
              <button type="button" data-command="justifyLeft" title="Align Left"><i class="material-icons">format_align_left</i></button>
              <button type="button" data-command="justifyCenter" title="Align Center"><i class="material-icons">format_align_center</i></button>
              <button type="button" data-command="justifyRight" title="Align Right"><i class="material-icons">format_align_right</i></button>
              <button type="button" data-command="removeFormat" title="Clear Formatting"><i class="material-icons">format_clear</i></button>
            </div>
            <div class="preview-content" id="editableContent" contenteditable="true">
              No content to preview yet. Please upload a DOCX file or select a JS file from dropdown.
            </div>
          </div>
          <div id="markdownContent" class="content-tab-panel">
            <div class="markdown-toolbar">
              <button type="button" class="copy-markdown-btn" title="Copy Markdown">Copy Markdown</button>
            </div>
            <div class="preview-content markdown-editor" contenteditable="true">
              No markdown content yet.
            </div>
          </div>
          <div id="convertedContent" class="content-tab-panel">
            <div class="js-editor-toolbar">
              <button type="button" class="js-format-btn" title="Format JS">Format Code</button>
              <div class="editor-toggle">
                <span>Auto-update from content:</span>
                <label class="switch">
                  <input type="checkbox" id="autoUpdateToggle" checked>
                  <span class="slider round"></span>
                </label>
              </div>
            </div>
            <div class="preview-content js-editor" contenteditable="true">
              No converted content yet.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Manager Section -->
    <div id="manager-tab" class="main-tab-content">
      <div class="kb-manager-container">
        <div class="action-bar">
          <div class="dropdown-container">
            <label for="loader-select">Knowledge Base Loader (kbLoader .js)</label>
            <select id="loader-select">
              <option value="">Select a loader file</option>
            </select>
          </div>
           <div class="action-buttons" id="manager-save-button-container">
                <!-- Save Changes button will be added here dynamically -->
           </div>
        </div>

        <div class="action-bar">
          <div class="dropdown-container">
            <label for="category-select">Assign to Category</label>
            <select id="category-select">
              <option value="">Select a category</option>
            </select>
          </div>

          <div class="dropdown-container">
            <label for="kb-select">Select Knowledge Base</label>
            <select id="kb-select">
              <option value="">Select a knowledge base</option>
            </select>
          </div>

          <div class="action-buttons">
            <button id="assign-button" class="primary-button" disabled>Assign</button>
          </div>
        </div>

        <div class="section">
          <div class="section-header">
            <h2>Categories</h2>
            <button id="add-category-button" class="icon-button primary-button">
              <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="16"></line>
                <line x1="8" y1="12" x2="16" y2="12"></line>
              </svg>
              <span>Add Category</span>
            </button>
          </div>

          <div id="add-category-form" class="category-form hidden">
            <h3>Add New Category</h3>
            <div class="input-group">
              <input type="text" id="new-category-input" placeholder="Category name">
              <button id="save-category-button" class="green-icon-button" title="Save Category">
                <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
              </button>
              <button id="cancel-category-button" class="red-button" title="Cancel">
                <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
          </div>

          <ul id="category-list" class="category-list"></ul>
          <p id="no-categories" class="text-gray hidden">No categories loaded or defined. Select a loader file or add a new category.</p>
        </div>

        <div class="section">
          <div class="section-header">
            <h2>All Knowledge Bases</h2>
          </div>
          <ul id="all-kb-list" class="kb-list"></ul>
          <p id="no-kb" class="text-gray hidden">No knowledge bases loaded or defined. Select a loader file.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Templates (for KB Manager) -->
  <template id="category-template">
    <li class="category-item" data-id="" data-collapsed="true"> <!-- Start collapsed -->
      <div class="category-header">
        <span class="category-name"></span>
        <div class="category-header-actions">
          <button class="remove-category-button red-icon-button" title="Remove Category">
            <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="3 6 5 6 21 6"></polyline>
              <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              <line x1="10" y1="11" x2="10" y2="17"></line>
              <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
          </button>
          <svg class="chevron-icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="6 9 12 15 18 9"></polyline>
          </svg>
        </div>
      </div>
      <div class="category-content"> <!-- Content is always present, hidden via CSS -->
        <div class="kb-header">
          <h4>Knowledge Bases in this Category</h4>
        </div>
        <ul class="kb-list category-kb-list" data-category-id=""></ul>
        <p class="no-kbs text-gray hidden">No knowledge bases in this category. Use the assignment dropdown above or drag & drop to add.</p>
      </div>
    </li>
  </template>

  <template id="kb-template">
    <li class="kb-item draggable" data-id="" draggable="true">
      <div class="kb-info-container">
        <span class="drag-handle" title="Drag to reorder or move to another category">
          <svg class="icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line>
            <line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>
          </svg>
        </span>
        <span class="kb-name"></span>
      </div>
      <button class="remove-kb-button red-icon-button" title="Remove from this Category">
        <svg class="icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </li>
  </template>

  <template id="all-kb-template">
    <li class="kb-item" data-id="">
      <div class="kb-info-container">
        <span class="kb-name"></span>
        <div class="kb-categories"></div>
      </div>
    </li>
  </template>

  <!-- Include Mammoth.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.17/mammoth.browser.min.js"></script>
  <!-- Include Turndown.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turndown/7.1.1/turndown.min.js"></script>

 <script>
  document.addEventListener('DOMContentLoaded', function () {
  // Confluence API Configuration (replace with your values)
  const CONFLUENCE_CONFIG = {
    baseUrl: 'YOUR_CONFLUENCE_BASE_URL',  // e.g., 'https://your-domain.atlassian.net/wiki'
    pageId: 'YOUR_PAGE_ID',               // The Confluence page ID where attachments are stored
    apiToken: 'YOUR_API_TOKEN',           // API token for authentication
    headers: {
      'Authorization': 'Bearer YOUR_API_TOKEN',
      'Content-Type': 'application/json',
      'X-Atlassian-Token': 'no-check'
    }
  };

  // Global Variables
  let currentFileSource = null;
  let currentJsObject = null;
  let markdownContent = null;

  // DOM Elements
  const dropZone = document.getElementById('dropZone');
  const fileInput = document.getElementById('fileInput');
  const browseBtn = document.getElementById('browseBtn');
  const fileInfo = document.getElementById('fileInfo');
  const fileName = document.getElementById('fileName');
  const fileSize = document.getElementById('fileSize');
  const editableContent = document.getElementById('editableContent');
  const autoUpdateToggle = document.getElementById('autoUpdateToggle');
  const outputFileName = document.getElementById('outputFileName');
  const exportBtn = document.getElementById('exportBtn');
  const alertBox = document.getElementById('alertBox');
  const tabs = document.querySelectorAll('.tab');
  const fileDropdown = document.getElementById('fileDropdown');
  const exportTypeSelector = document.getElementById('exportTypeSelector');
  const copyMarkdownBtn = document.querySelector('.copy-markdown-btn');
  const markdownEditor = document.querySelector('.markdown-editor');

  // Variables to store content and state
  let docxContent = null;
  let jsObject = null;
  let isAutoUpdateEnabled = true;
  let documentTitle = '';
  let documentName = '';
  let documentCategory = '';
  let loadedJsFilename = null;

  // Prevent default drag behaviors
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropZone.addEventListener(eventName, preventDefaults, false);
    document.body.addEventListener(eventName, preventDefaults, false);
  });

  // Highlight dropZone on drag events
  ['dragenter', 'dragover'].forEach(eventName => {
    dropZone.addEventListener(eventName, () => dropZone.classList.add('active'), false);
  });
  ['dragleave', 'drop'].forEach(eventName => {
    dropZone.addEventListener(eventName, () => dropZone.classList.remove('active'), false);
  });

  // File drop and file input handlers
  dropZone.addEventListener('drop', handleDrop, false);
  browseBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', handleFiles);

  // Tab switching
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      const tabId = tab.getAttribute('data-tab');
      document.getElementById(tabId + 'Content').classList.add('active');
      
      // If switching to markdown tab, make sure markdown is up to date
      if (tabId === 'markdown' && docxContent) {
        updateMarkdownContent();
      }
    });
  });

  // Auto-update toggle
  autoUpdateToggle.addEventListener('change', function () {
    isAutoUpdateEnabled = this.checked;
  });

  // Format JS button
  document.querySelector('.js-format-btn').addEventListener('click', function () {
    try {
      const jsEditorElement = document.querySelector('.js-editor');
      const jsContent = jsEditorElement.textContent;
      const formattedJs = formatJavaScript(jsContent);
      jsEditorElement.textContent = formattedJs;
    } catch (error) {
      showAlert('Error formatting JavaScript. Check for syntax errors.', 'error');
    }
  });

  // Copy Markdown button
  copyMarkdownBtn.addEventListener('click', function() {
    const markdownText = markdownEditor.textContent;
    copyToClipboard(markdownText);
  });

  // Editor toolbar buttons for rich text editing
  document.querySelectorAll('.editor-toolbar button').forEach(button => {
    button.addEventListener('click', function () {
      const command = this.dataset.command;
      const value = this.dataset.value || null;
      document.execCommand(command, false, value);
      // Update JS conversion immediately after command execution
      if (isAutoUpdateEnabled) {
        updateConvertedJS();
        updateMarkdownContent();
      }
    });
  });

  // Update converted JS when editable content changes
  editableContent.addEventListener('input', function () {
    if (isAutoUpdateEnabled) {
      updateConvertedJS();
      updateMarkdownContent();
    }
  });

  // Export type selector event handler
  exportTypeSelector.addEventListener('change', function() {
    const selectedType = this.value;
    
    // Update the JS editor content based on the selected export type
    if (jsObject) {
      const jsEditorElement = document.querySelector('.js-editor');
      
      if (selectedType === 'llm-primer' && jsObject.name) {
        // If switching to llm-primer format, update the JS view
        const primerCode = generateLlmPrimerCode(jsObject.name, markdownContent || '');
        jsEditorElement.textContent = primerCode;
      } else if (selectedType === 'markdown-js') {
        // If switching to markdown-js format, update the JS view
        jsEditorElement.textContent = generateMarkdownJs(markdownContent || '', documentTitle);
      } else {
        // Default to JS object format
        jsEditorElement.textContent = generateJsCode(jsObject);
      }
    }
  });

  // Fetch all attachments from Confluence
  async function fetchConfluenceAttachments() {
    try {
      const response = await fetch(
        `${CONFLUENCE_CONFIG.baseUrl}/rest/api/content/${CONFLUENCE_CONFIG.pageId}/child/attachment`, 
        { headers: CONFLUENCE_CONFIG.headers }
      );
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      return data.results || [];
    } catch (error) {
      console.error('Error fetching attachments:', error);
      throw error;
    }
  }

  // Fetch specific attachment content
  async function fetchConfluenceAttachmentContent(filename) {
    try {
      // First get all attachments to find the one with matching filename
      const attachments = await fetchConfluenceAttachments();
      const attachment = attachments.find(att => att.title === filename);
      
      if (!attachment) {
        return Promise.reject(new Error(`Attachment not found: ${filename}`));
      }
      
      // Get attachment content
      const response = await fetch(
        `${CONFLUENCE_CONFIG.baseUrl}/download/attachments/${CONFLUENCE_CONFIG.pageId}/${attachment.id}/${encodeURIComponent(filename)}`,
        { headers: CONFLUENCE_CONFIG.headers }
      );
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      return response.text();
    } catch (error) {
      console.error('Error fetching attachment content:', error);
      throw error;
    }
  }

  // Upload file to Confluence attachments
  async function uploadToConfluence(file, filename) {
    try {
      // Check if file already exists
      const attachments = await fetchConfluenceAttachments();
      const existingAttachment = attachments.find(att => att.title === filename);
      
      // Create form data
      const formData = new FormData();
      formData.append('file', file);
      
      // Set headers for file upload (remove Content-Type so browser sets correct boundary)
      const uploadHeaders = { ...CONFLUENCE_CONFIG.headers };
      delete uploadHeaders['Content-Type'];
      
      let response;
      
      if (existingAttachment) {
        // Update existing attachment
        response = await fetch(
          `${CONFLUENCE_CONFIG.baseUrl}/rest/api/content/${CONFLUENCE_CONFIG.pageId}/child/attachment/${existingAttachment.id}/data`, 
          { 
            method: 'POST', 
            headers: uploadHeaders,
            body: formData 
          }
        );
      } else {
        // Create new attachment
        response = await fetch(
          `${CONFLUENCE_CONFIG.baseUrl}/rest/api/content/${CONFLUENCE_CONFIG.pageId}/child/attachment`, 
          { 
            method: 'POST', 
            headers: uploadHeaders,
            body: formData 
          }
        );
      }
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Upload failed: ${response.status} - ${errorText}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error uploading to Confluence:', error);
      throw error;
    }
  }

  // Copy text to clipboard
  function copyToClipboard(text) {
    navigator.clipboard.writeText(text)
      .then(() => {
        showAlert('Content copied to clipboard!', 'success');
      })
      .catch(error => {
        console.error('Error copying to clipboard:', error);
        showAlert('Error copying to clipboard.', 'error');
      });
  }

  // Convert markdown to HTML
  function markdownToHtml(markdown) {
    // Simple markdown to HTML converter
    let html = '';
    const lines = markdown.split('\n');
    let inCodeBlock = false;
    let inList = false;
    let listType = '';
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trimRight();
      
      // Skip empty lines
      if (line.trim() === '' && !inCodeBlock) {
        if (inList) {
          inList = false;
          html += listType === 'ul' ? '</ul>' : '</ol>';
          listType = '';
        }
        html += '<br>';
        continue;
      }
      
      // Check for headings (# Heading)
      if (line.match(/^#+\s+/) && !inCodeBlock) {
        if (inList) {
          inList = false;
          html += listType === 'ul' ? '</ul>' : '</ol>';
          listType = '';
        }
        
        const match = line.match(/^(#+)\s+(.*)/);
        if (match) {
          const level = Math.min(match[1].length, 6);
          const text = match[2];
          html += `<h${level}>${text}</h${level}>`;
          continue;
        }
      }
      
      // Check for code blocks
      if (line.startsWith('```')) {
        inCodeBlock = !inCodeBlock;
        if (inCodeBlock) {
          html += '<pre><code>';
        } else {
          html += '</code></pre>';
        }
        continue;
      }
      
      // If we're in a code block, just add the line as is
      if (inCodeBlock) {
        html += line + '\n';
        continue;
      }
      
      // Check for bullet lists
      if (line.match(/^[*-]\s+/)) {
        if (!inList) {
          inList = true;
          listType = 'ul';
          html += '<ul>';
        } else if (listType !== 'ul') {
          // We're switching from an ordered list to an unordered list
          html += '</ol><ul>';
          listType = 'ul';
        }
        html += `<li>${line.replace(/^[*-]\s+/, '')}</li>`;
        continue;
      }
      
      // Check for numbered lists
      if (line.match(/^\d+\.\s+/)) {
        if (!inList) {
          inList = true;
          listType = 'ol';
          html += '<ol>';
        } else if (listType !== 'ol') {
          // We're switching from an unordered list to an ordered list
          html += '</ul><ol>';
          listType = 'ol';
        }
        html += `<li>${line.replace(/^\d+\.\s+/, '')}</li>`;
        continue;
      }
      
      // If we were in a list but this line doesn't match a list item
      if (inList && !line.match(/^[*-]\s+/) && !line.match(/^\d+\.\s+/)) {
        inList = false;
        html += listType === 'ul' ? '</ul>' : '</ol>';
        listType = '';
      }
      
      // Check for bold and italic text
      let formattedLine = line
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/__(.*?)__/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/_(.*?)_/g, '<em>$1</em>');
      
      // Regular text
      html += `<p>${formattedLine}</p>`;
    }
    
    // Make sure we close any open tags
    if (inCodeBlock) html += '</code></pre>';
    if (inList) html += listType === 'ul' ? '</ul>' : '</ol>';
    
    return html;
  }

  // Update JS conversion based on the edited content using new semantic conversion
  function updateConvertedJS() {
    const editedContent = editableContent.innerHTML;
    jsObject = convertHtmlToJsObject(editedContent);
    const jsEditorElement = document.querySelector('.js-editor');
    
    // Check the selected export type
    const exportType = exportTypeSelector.value;
    
    if (exportType === 'llm-primer' && jsObject.name) {
      // If llm-primer format is selected, generate the appropriate code
      jsEditorElement.textContent = generateLlmPrimerCode(jsObject.name, markdownContent || '');
    } else if (exportType === 'markdown-js') {
      // If markdown-js format is selected, generate the appropriate code
      jsEditorElement.textContent = generateMarkdownJs(markdownContent || '', documentTitle);
    } else {
      // Default to JS object format
      jsEditorElement.textContent = generateJsCode(jsObject);
    }
  }

  // Generate llmPrimerRegister code
  function generateLlmPrimerCode(name, content) {
    return `llmPrimerRegister('${name}', \`
${content}
\`);`;
  }

  // Update Markdown conversion based on the edited content
  function updateMarkdownContent() {
    // If we have a llmPrimer format object, update the markdown content from the HTML editor
    if (jsObject && jsObject.type === 'markdown' && jsObject.format === 'llmPrimer') {
      const editedContent = editableContent.innerHTML;
      
      // Use TurndownService to convert HTML to Markdown
      const turndownService = new TurndownService({
        headingStyle: 'atx',
        codeBlockStyle: 'fenced',
        emDelimiter: '_'
      });
      
      markdownContent = turndownService.turndown(editedContent);
      markdownEditor.textContent = markdownContent;
      
      // Update the jsObject content
      jsObject.content = markdownContent;
      
      // Update the JS editor if we're in llm-primer format
      if (exportTypeSelector.value === 'llm-primer') {
        const jsEditorElement = document.querySelector('.js-editor');
        jsEditorElement.textContent = generateLlmPrimerCode(jsObject.name, markdownContent);
      }
    } else {
      // Standard behavior for non-llmPrimer formats
      const editedContent = editableContent.innerHTML;
      
      // Use TurndownService to convert HTML to Markdown
      const turndownService = new TurndownService({
        headingStyle: 'atx',
        codeBlockStyle: 'fenced',
        emDelimiter: '_'
      });
      
      markdownContent = turndownService.turndown(editedContent);
      markdownEditor.textContent = markdownContent;
    }
  }

  // Export button handler
  exportBtn.addEventListener('click', exportFile);

  // Export file function (updated to use REST API)
  function exportFile() {
    // Update content from current editor tab
    if (document.querySelector('.tab[data-tab="original"]').classList.contains('active')) {
      const editedContent = editableContent.innerHTML;
      updateMarkdownContent();
    } else if (document.querySelector('.tab[data-tab="markdown"]').classList.contains('active')) {
      markdownContent = markdownEditor.textContent;
    }
    
    // Ensure KB name exists
    if (!jsObject || !jsObject.name) {
      // Create a knowledge base name from the filename
      const baseName = outputFileName.value.replace(/(_kb)?\.js$/i, '');
      const cleanKbName = baseName.toLowerCase().replace(/\s+/g, '').replace(/[^a-z0-9_]/g, '');
      
      if (!jsObject) jsObject = {};
      jsObject.name = cleanKbName;
    }
    
    // ALWAYS use the LLM Primer format for export, regardless of the selected export type
    const jsContentToSave = generateLlmPrimerCode(jsObject.name, markdownContent || '');

    // Get the filename and ensure it starts with "kb_"
    let finalFileName = outputFileName.value;
    if (!finalFileName.startsWith('kb_')) {
      finalFileName = 'kb_' + finalFileName;
    }
    if (!finalFileName.endsWith('.js')) {
      finalFileName += '.js';
    }
    
    const jsFileBlob = new Blob([jsContentToSave], { type: 'application/javascript' });
    const jsFile = new File([jsFileBlob], finalFileName, { type: 'application/javascript' });
    
    // Update button state and upload to Confluence
    exportBtn.disabled = true;
    exportBtn.textContent = 'Saving...';
    
    uploadToConfluence(jsFile, finalFileName)
      .then(() => {
        showAlert('Successfully exported to Confluence!', 'success');
        exportBtn.disabled = false;
        exportBtn.textContent = 'Export';
        currentFileSource = null;
        
        // Refresh the dropdown to show the new file
        populateDropdown();
      })
      .catch(error => {
        showAlert(`Error exporting file: ${error.message}`, 'error');
        exportBtn.disabled = false;
        exportBtn.textContent = 'Export';
        console.error('Export error:', error);
      });
  }

  // Prevent default drag events
  function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
  }

  function handleDrop(e) {
    const dt = e.dataTransfer;
    const files = dt.files;
    handleFiles({ target: { files } });
  }

  function handleFiles(e) {
    const files = e.target.files;
    if (files.length > 0) {
      const file = files[0];
      loadedJsFilename = null;
      if (file.name.endsWith('.docx')) {
        const baseName = file.name.replace('.docx', '');
        outputFileName.value = `kb_${baseName}.js`;
        processDocxFile(file);
      } else {
        showAlert('Please upload a .docx file.', 'error');
      }
    }
  }

  // Process DOCX file with enhanced semantic structure preservation
  function processDocxFile(file) {
    editableContent.textContent = '';
    document.querySelector('.js-editor').textContent = '';
    markdownEditor.textContent = '';
    docxContent = null;
    jsObject = null;
    markdownContent = null;
    documentTitle = '';
    documentName = '';
    documentCategory = '';
    
    // Extract base name from file for use as knowledge base name
    const baseFileName = file.name.replace(/\.docx$/i, '');
    const cleanKbName = baseFileName.replace(/\s+/g, '').toLowerCase();
    
    outputFileName.value = `kb_${baseFileName}_kb.js`;
    fileInfo.classList.add('show');
    fileName.textContent = `File: ${file.name}`;
    fileSize.textContent = `Size: ${formatBytes(file.size)}`;
    
    const reader = new FileReader();
    reader.onload = function (e) {
      const arrayBuffer = e.target.result;
      // Define a styleMap to preserve semantic elements
      const styleMap = [
        "p[style-name='Title'] => h1",
        "p[style-name='Heading 1'] => h1",
        "p[style-name='Heading 2'] => h2",
        "p[style-name='Heading 3'] => h3",
        "p[style-name='Heading 4'] => h4",
        "p[style-name='Heading 5'] => h5",
        "p[style-name='Heading 6'] => h6",
        "p[style-name='Normal'] => p",
        "p[style-name='List Paragraph'] => li"
      ];
      mammoth.convertToHtml({ arrayBuffer: arrayBuffer, styleMap: styleMap })
        .then(result => {
          docxContent = result.value;
          editableContent.innerHTML = docxContent;
          
          // Convert to JS object
          jsObject = convertHtmlToJsObject(docxContent);
          
          // Set knowledge base name with priority order:
          // 1. Use explicit name from document if found
          // 2. Use category + filename if category exists
          // 3. Use cleaned filename as fallback
          if (jsObject.name) {
            // Use name from document if available (from #Name: tag)
            const kbName = jsObject.name.toLowerCase().replace(/\s+/g, '');
            jsObject.name = kbName;
          } else if (jsObject.category) {
            // Use category + base name if category exists
            const category = jsObject.category.toLowerCase().replace(/\s+/g, '');
            jsObject.name = category + '_' + cleanKbName;
          } else {
            // Default to cleaned filename
            jsObject.name = cleanKbName;
          }
          
          // If the document has a title, use it as well
          if (jsObject.title) {
            documentTitle = jsObject.title;
          } else {
            documentTitle = baseFileName;
          }
          
          // Convert HTML to markdown
          updateMarkdownContent();
          
          // Always default to LLM Primer format
          document.querySelector('.js-editor').textContent = generateLlmPrimerCode(
            jsObject.name, 
            markdownContent
          );
          
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export';
          showAlert('Document successfully loaded! You can now edit the content before exporting.', 'success');
        })
        .catch(error => {
          console.error('Error converting docx:', error);
          showAlert('Error processing DOCX file.', 'error');
        });
    };
    reader.readAsArrayBuffer(file);
  }

  // Convert HTML to a JS object with section markers
  function convertHtmlToJsObject(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const result = {};
    
    // Initialize section tracking
    let currentSection = null;
    let sectionContent = [];
    
    // Regular expressions for section markers
    const titleRegex = /#Title:\s*(.*)/i;
    const nameRegex = /#Name:\s*(.*)/i;
    const categoryRegex = /#Category:\s*(.*)/i;
    const sectionStartRegex = /#(\w+)Start/i;
    const sectionEndRegex = /#(\w+)End/i;
    
    // Create content array for non-sectioned content
    result.content = [];
    
    // Traverse the document body
    let nodes = Array.from(doc.body.childNodes);
    
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      
      if (node.nodeType === Node.ELEMENT_NODE) {
        // Convert the element to its object representation
        const obj = convertElementToObject(node);
        
        // Check for metadata markers in headings
        if (obj.type === 'heading') {
          // Extract Title, Name, and Category
          const titleMatch = obj.content.match(titleRegex);
          const nameMatch = obj.content.match(nameRegex);
          const categoryMatch = obj.content.match(categoryRegex);
          const sectionStartMatch = obj.content.match(sectionStartRegex);
          const sectionEndMatch = obj.content.match(sectionEndRegex);
          
          if (titleMatch) {
            result.title = titleMatch[1].trim();
            documentTitle = result.title;
            continue;
          } else if (nameMatch) {
            result.name = nameMatch[1].trim();
            documentName = result.name;
            continue;
          } else if (categoryMatch) {
            result.category = categoryMatch[1].trim();
            documentCategory = result.category;
            continue;
          } else if (sectionStartMatch) {
            // Start collecting content for this section
            currentSection = sectionStartMatch[1].toLowerCase().trim();
            sectionContent = [];
            continue;
          } else if (sectionEndMatch && currentSection) {
            // End of section - process and store the collected content
            const sectionName = sectionEndMatch[1].toLowerCase().trim();
            
            if (sectionName === currentSection) {
              // Combine section content into a single string with line breaks
              result[currentSection] = sectionContent
                .map(item => {
                  if (typeof item === 'string') return item;
                  
                  if (item.type === 'heading') {
                    return `${'#'.repeat(item.level)} ${item.content}`;
                  } else if (item.type === 'paragraph') {
                    return item.content;
                  } else if (item.type === 'list') {
                    return item.items.map(li => `${item.ordered ? '1. ' : '* '}${li}`).join('\n');
                  } else {
                    return item.content;
                  }
                })
                .join('\n\n');
              
              currentSection = null;
              sectionContent = [];
            }
            continue;
          }
        }
        
        // If we're currently collecting section content, add this element
        if (currentSection) {
          sectionContent.push(obj);
        } else {
          // Otherwise, add to regular content array
          result.content.push(obj);
        }
      } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
        // Handle text nodes
        if (currentSection) {
          sectionContent.push(node.textContent.trim());
        } else {
          result.content.push({ type: 'text', content: node.textContent.trim() });
        }
      }
    }
    
    // If content array is empty, remove it
    if (result.content.length === 0) {
      delete result.content;
    }
    
    return result;
  }

  // Helper function to convert an HTML element to an object
  function convertElementToObject(element) {
    const tag = element.tagName.toLowerCase();
    let obj = {};
    
    if (tag.match(/^h[1-6]$/)) {
      obj.type = 'heading';
      obj.level = parseInt(tag.charAt(1), 10);
      obj.content = element.textContent.trim();
    } else if (tag === 'p') {
      obj.type = 'paragraph';
      obj.content = element.innerHTML.trim();
    } else if (tag === 'ul' || tag === 'ol') {
      obj.type = 'list';
      obj.ordered = (tag === 'ol');
      obj.items = [];
      Array.from(element.children).forEach(li => {
        if (li.tagName.toLowerCase() === 'li') {
          obj.items.push(li.textContent.trim());
        }
      });
    } else {
      // For other elements, store tag and inner content
      obj.type = tag;
      obj.content = element.innerHTML.trim();
    }
    
    return obj;
  }

  // Generate JavaScript module code from the JS object
  function generateJsCode(jsObject) {
    const variableName = getJsVariableName(jsObject.title, jsObject.name, jsObject.category);
    const code = `/**
 * ${jsObject.title || jsObject.name || 'Knowledge Base'}
 * JavaScript module format for easy importing
 */
const ${variableName} = ${JSON.stringify(jsObject, null, 2)};

// Make the data available globally
window.${variableName} = ${variableName};`;
    return code;
  }

  // Generate JavaScript module with Markdown content
  function generateMarkdownJs(markdown, title) {
    // Use a standardized variable name
    const variableName = 'markdownContent';
    const escapedMarkdown = markdown
      .replace(/\\/g, '\\\\')
      .replace(/'/g, "\\'")
      .replace(/\n/g, '\\n');
    
    // Create code that matches the example format exactly
    const code = `/**
 * Generated JavaScript file with Markdown content
 * Original file: ${outputFileName.value.replace('.js', '.docx')}
 * Generated: ${new Date().toISOString()}
 */

const ${variableName} = '${escapedMarkdown}';

// Export the markdown content
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { ${variableName} };
}

// Make available in browser context
if (typeof window !== 'undefined') {
  window.${variableName} = ${variableName};
}`;
    return code;
  }

  // Generate a valid variable name with category support
  function getJsVariableName(title, name, category) {
    let base = title || name || 'knowledgeBase';
    base = base.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '').replace(/_+/g, '_');
    
    // If category is provided, use it as part of the variable name
    if (category) {
      const cleanCategory = category.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '').replace(/_+/g, '_');
      return `${cleanCategory}_${base}_data`;
    }
    
    return `${base}_data`;
  }

  // Load JS file content (updated to use REST API)
  function loadJSFileContent(filename) {
    fetchConfluenceAttachmentContent(filename)
      .then(jsContent => {
        const jsEditorElement = document.querySelector('.js-editor');
        jsEditorElement.textContent = jsContent;
        
        try {
          const extractedObject = extractJsObjectFromCode(jsContent);
          jsObject = extractedObject;
          currentJsObject = jsObject;
          
          // Check if this is a markdown file
          if (extractedObject.type === 'markdown') {
            // If it's a llmPrimer format, set the export type selector
            if (extractedObject.format === 'llmPrimer') {
              exportTypeSelector.value = 'llm-primer';
              
              // Set the markdown content
              markdownContent = extractedObject.content;
              markdownEditor.textContent = markdownContent;
              
              // Convert markdown to HTML for the rich text editor
              const html = markdownToHtml(markdownContent);
              
              // Set the HTML content
              editableContent.innerHTML = html;
              
              // Switch to the original content tab
              document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
              document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
              document.querySelector('.tab[data-tab="original"]').classList.add('active');
              document.getElementById('originalContent').classList.add('active');
            } else {
              // Standard markdown file
              exportTypeSelector.value = 'markdown-js';
              
              // Switch to the markdown tab
              document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
              document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
              document.querySelector('.tab[data-tab="markdown"]').classList.add('active');
              document.getElementById('markdownContent').classList.add('active');
              
              // Set the markdown content
              markdownContent = extractedObject.content;
              markdownEditor.textContent = markdownContent;
              editableContent.innerHTML = `<p>This file contains Markdown content. View the Markdown tab to see it.</p>`;
            }
          } else {
            // This is a regular JS object file
            exportTypeSelector.value = 'js-object';
            
            const richTextHtml = generateRichText(jsObject);
            editableContent.innerHTML = richTextHtml;
            
            // Also update markdown content
            updateMarkdownContent();
          }
          
          outputFileName.value = filename;
          exportBtn.disabled = false;
          exportBtn.textContent = 'Export';
          loadedJsFilename = filename;
          docxContent = null;
          fileInfo.classList.remove('show');
          
          showAlert(`JS File '${filename}' loaded from Confluence!`, 'success');
          currentFileSource = 'dropdown';
        } catch (e) {
          console.error("Error parsing or converting JS content:", e);
          editableContent.innerHTML = '<p>Error displaying content as Rich Text. Invalid JS Object format.</p>';
          showAlert(`Error processing JavaScript content: ${e.message}`, 'error');
        }
      })
      .catch(error => {
        console.error('Error loading JS file:', error);
        showAlert(`Error loading JS File '${filename}' from Confluence: ${error.message}`, 'error');
        editableContent.textContent = 'Error loading content.';
        const jsEditorElement = document.querySelector('.js-editor');
        jsEditorElement.textContent = 'Error loading content.';
      });
  }

  // Extract JS object from code string - IMPROVED VERSION
  function extractJsObjectFromCode(jsCode) {
    try {
      // Try to match llmPrimerRegister format first
      let primerMatch = jsCode.match(/llmPrimerRegister\s*\(\s*['"]([^'"]+)['"]\s*,\s*`([\s\S]*?)`\s*\)/);
      if (primerMatch && primerMatch[1] && primerMatch[2]) {
        // This is a llmPrimerRegister format
        const name = primerMatch[1];
        markdownContent = primerMatch[2].trim();
        markdownEditor.textContent = markdownContent;
        return { 
          type: 'markdown', 
          content: markdownContent,
          name: name,
          format: 'llmPrimer'
        };
      }
      
      // Try extracting standard markdown content
      let markdownMatch = jsCode.match(/const\s+[a-zA-Z0-9_]+\s*=\s*'([\s\S]*?)';/);
      if (markdownMatch && markdownMatch[1]) {
        // This appears to be a markdown JS file
        markdownContent = markdownMatch[1].replace(/\\n/g, '\n').replace(/\\'/g, "'").replace(/\\\\/g, '\\');
        markdownEditor.textContent = markdownContent;
        return { type: 'markdown', content: markdownContent };
      }
      
      // Try matching const assignment for object
      let objectMatch = jsCode.match(/const\s+[a-zA-Z0-9_]+\s*=\s*(\{[\s\S]*?\});/);
      
      // If not found, try matching let or var assignment
      if (!objectMatch) {
        objectMatch = jsCode.match(/(?:let|var)\s+[a-zA-Z0-9_]+\s*=\s*(\{[\s\S]*?\});/);
      }
      
      // If still not found, try matching just an object literal
      if (!objectMatch) {
        objectMatch = jsCode.match(/(\{[\s\S]*\})/);
      }
      
      if (objectMatch && objectMatch[1]) {
        return JSON.parse(objectMatch[1]);
      }
      
      throw new Error("No valid JS object found.");
    } catch (error) {
      console.error("Error extracting JS object:", error);
      throw new Error("Failed to extract valid JS object from code");
    }
  }

  // Generate rich text HTML from the JS object - IMPROVED VERSION
  function generateRichText(obj) {
    let html = '';
    
    // Check if this is a markdown object
    if (obj.type === 'markdown') {
      if (obj.format === 'llmPrimer') {
        // For llmPrimer format, convert markdown to HTML
        return markdownToHtml(obj.content);
      } else if (obj.content) {
        markdownContent = obj.content;
        markdownEditor.textContent = markdownContent;
        
        // For markdown files, we'll display a simple message in the editor
        return `<p>This file contains Markdown content. View the Markdown tab to see it.</p>`;
      }
    }
    
    // Add title, name, and category if they exist
    if (obj.title) {
      html += `<h1><strong>#Title: ${obj.title}</strong></h1>`;
    }
    if (obj.name) {
      html += `<h1><strong>#Name: ${obj.name}</strong></h1>`;
    }
    if (obj.category) {
      html += `<h1><strong>#Category: ${obj.category}</strong></h1>`;
    }
    
    // Process all sections dynamically instead of just predefined ones
    for (const key in obj) {
      // Skip standard properties and arrays
      if (['title', 'name', 'category', 'content'].includes(key) || !obj[key] || Array.isArray(obj[key])) {
        continue;
      }
      
      // For each custom section
      if (typeof obj[key] === 'string' && obj[key].trim() !== '') {
        html += `<h2><strong>#${key}Start</strong></h2>`;
        
        // Process section content
        let sectionHtml = '';
        const paragraphs = obj[key].split('\n\n');
        
        for (let i = 0; i < paragraphs.length; i++) {
          const paragraph = paragraphs[i].trim();
          
          if (paragraph === '') continue;
          
          // Check if it's a heading
          if (paragraph.startsWith('#')) {
            const match = paragraph.match(/^(#+)\s+(.*)/);
            if (match) {
              const level = Math.min(match[1].length, 6); // Ensure level is between 1-6
              const text = match[2];
              sectionHtml += `<h${level}>${text}</h${level}>`;
              continue;
            }
          }
          
          // Check if paragraph contains multiple lines that might be list items
          const lines = paragraph.split('\n');
          
          // Check if it's a bullet list (starts with * or -)
          if (lines.length > 1 && lines.some(line => line.trim().match(/^[*-]\s+/))) {
            sectionHtml += '<ul>';
            
            for (const line of lines) {
              const trimmed = line.trim();
              if (trimmed && trimmed.match(/^[*-]\s+/)) {
                const itemText = trimmed.replace(/^[*-]\s+/, '');
                sectionHtml += `<li>${itemText}</li>`;
              }
            }
            
            sectionHtml += '</ul>';
            continue;
          }
          
          // Check if it's a numbered list (starts with number. or number))
          if (lines.length > 1 && lines.some(line => line.trim().match(/^\d+[\.\)]\s+/))) {
            sectionHtml += '<ol>';
            
            for (const line of lines) {
              const trimmed = line.trim();
              if (trimmed && trimmed.match(/^\d+[\.\)]\s+/)) {
                const itemText = trimmed.replace(/^\d+[\.\)]\s+/, '');
                sectionHtml += `<li>${itemText}</li>`;
              }
            }
            
            sectionHtml += '</ol>';
            continue;
          }
          
          // Regular paragraph - preserve any HTML that might exist within it
          sectionHtml += `<p>${paragraph}</p>`;
        }
        
        html += sectionHtml;
        html += `<h2><strong>#${key}End</strong></h2>`;
      }
    }
    
    // Add generic content if it exists
    if (obj.content && Array.isArray(obj.content)) {
      obj.content.forEach(item => {
        if (item.type === 'heading') {
          html += `<h${item.level}>${item.content}</h${item.level}>`;
        } else if (item.type === 'paragraph') {
          html += `<p>${item.content}</p>`;
        } else if (item.type === 'list') {
          html += item.ordered ? '<ol>' : '<ul>';
          item.items.forEach(li => {
            html += `<li>${li}</li>`;
          });
          html += item.ordered ? '</ol>' : '</ul>';
        } else if (item.type === 'text') {
          html += `<p>${item.content}</p>`;
        } else {
          html += `<div>${item.content}</div>`;
        }
      });
    }
    
    return html;
  }

  // Format JavaScript code
  function formatJavaScript(jsCode) {
    try {
      // Check if this is a llmPrimer format file
      const primerMatch = jsCode.match(/llmPrimerRegister\s*\(\s*['"]([^'"]+)['"]\s*,\s*`([\s\S]*?)`\s*\)/);
      
      if (primerMatch) {
        // This is a llmPrimer format file
        const name = primerMatch[1];
        const content = primerMatch[2].trim();
        
        return `llmPrimerRegister('${name}', \`
${content}
\`);`;
      }
      
      // Check if this is a markdown JS file
      const markdownMatch = jsCode.match(/const\s+[a-zA-Z0-9_]+\s*=\s*'([\s\S]*?)';/);
      if (markdownMatch) {
        // This is a markdown file, we'll just clean up the formatting a bit
        const variableName = jsCode.match(/const\s+([a-zA-Z0-9_]+)/)[1];
        const markdownContent = markdownMatch[1]
          .replace(/\\n/g, '\n')
          .replace(/\\'/g, "'")
          .replace(/\\\\/g, '\\');
        
        return `/**
 * Markdown Content
 * JavaScript module with markdown content
 * Generated: ${new Date().toISOString()}
 */
const ${variableName} = '${markdownContent.replace(/\n/g, '\\n').replace(/'/g, "\\'")}';

// Make the markdown content available globally
window.${variableName} = ${variableName};`;
      }
    
      // First try to extract the JSON object from the JavaScript code
      const match = jsCode.match(/const\s+[a-zA-Z0-9_]+\s*=\s*(\{[\s\S]*?\});/);
      if (match && match[1]) {
        const jsonObj = JSON.parse(match[1]);
        const formattedJson = JSON.stringify(jsonObj, null, 2);
        
        // Replace the original object with the formatted one
        return jsCode.replace(/const\s+[a-zA-Z0-9_]+\s*=\s*\{[\s\S]*?\};/, 
          `const ${getJsVariableName(jsonObj.title, jsonObj.name, jsonObj.category)} = ${formattedJson};`);
      }
      // If that fails, try to format the whole thing as JSON
      return JSON.stringify(JSON.parse(jsCode), null, 2);
    } catch (e) {
      console.warn('JavaScript formatting failed, returning original:', e);
      return jsCode;
    }
  }

  // Format file sizes
  function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }

  // Populate dropdown with kb_*.js files from Confluence
  function populateDropdown() {
    // Clear dropdown except for the first "Select a file" option
    while (fileDropdown.options.length > 1) {
      fileDropdown.remove(1);
    }
    
    // Show loading indicator
    const loadingOption = document.createElement('option');
    loadingOption.text = "Loading files...";
    fileDropdown.add(loadingOption);
    
    // Fetch attachments from Confluence
    fetchConfluenceAttachments()
      .then(attachments => {
        // Remove loading indicator
        fileDropdown.remove(fileDropdown.options.length - 1);
        
        // Filter for kb_*.js files and add to dropdown
        attachments
          .filter(att => att.title.startsWith('kb_') && att.title.endsWith('.js'))
          .forEach(attachment => {
            const option = document.createElement('option');
            option.value = attachment.title;
            option.textContent = attachment.title;
            fileDropdown.appendChild(option);
          });
        
        if (attachments.length === 0) {
          const noFilesOption = document.createElement('option');
          noFilesOption.text = "No KB files found";
          noFilesOption.disabled = true;
          fileDropdown.add(noFilesOption);
        }
      })
      .catch(error => {
        console.error('Error loading files:', error);
        fileDropdown.remove(fileDropdown.options.length - 1);
        
        const errorOption = document.createElement('option');
        errorOption.text = "Error loading files";
        errorOption.disabled = true;
        fileDropdown.add(errorOption);
        
        showAlert('Error loading files from Confluence. Check console for details.', 'error');
      });
    
    // Add change event handler to load selected files
    fileDropdown.addEventListener('change', function() {
      const selectedFileName = this.value;
      if (selectedFileName) {
        editableContent.textContent = '';
        document.querySelector('.js-editor').textContent = '';
        markdownEditor.textContent = '';
        docxContent = null;
        jsObject = null;
        markdownContent = null;
        documentTitle = '';
        documentName = '';
        documentCategory = '';
        fileInfo.classList.remove('show');
        loadedJsFilename = selectedFileName;
        outputFileName.value = selectedFileName;
        loadJSFileContent(selectedFileName);
      } else {
        editableContent.textContent = 'No content to preview yet. Please upload a DOCX file or select a JS file from dropdown.';
        document.querySelector('.js-editor').textContent = 'No converted content yet.';
        markdownEditor.textContent = 'No markdown content yet.';
        exportBtn.disabled = true;
        exportBtn.textContent = 'Export';
        loadedJsFilename = null;
        outputFileName.value = 'kb_knowledge-base.js';
        currentFileSource = null;
      }
    });
  }

  // Alert message display
  function showAlert(message, type) {
    alertBox.textContent = message;
    alertBox.className = `alert alert-${type} show`;
    setTimeout(() => {
      alertBox.classList.remove('show');
    }, 5000);
  }

  // Initial population of dropdown
  populateDropdown();
});
 </script>
</body>
</html>