<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Knowledge Base Editor (.DOCX to .JS/Markdown)</title>
  <!-- Font Awesome and Material Icons from CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <style>
    /* Global Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    body {
      background-color: #f5f8fa;
      color: #333;
      line-height: 1.6;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
       /* Add padding/margin to account for fixed header */
      padding-top: 100px; /* Adjust based on header height + desired spacing */
    }
    /* Header */
    .headerArea {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background-color: #1e293b;
      color: #fff !important;
      position: fixed; /* Changed from absolute to fixed for better scrolling */
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000; /* Ensure header is on top */
    }
    .headerArea h1 {
      color: #fff;
      margin-bottom: 0.5rem;
      font-weight: 500 !important;
    }

    /* Main Navigation Tabs (REMOVE IN SPLIT FILES)
    .main-nav-tabs {
      display: flex;
      margin-top: 80px;
      margin-bottom: 20px;
      border-bottom: 1px solid #ddd;
    }
    .main-nav-tab {
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      color: #6b7280;
      font-weight: 500;
    }
    .main-nav-tab.active {
      border-bottom-color: #3498db;
      color: #3498db;
      font-weight: 600;
    }
     (REMOVE IN SPLIT FILES) */
    .main-tab-content {
      /* This class will be removed from the outer container div */
      /* Instead, the content will be directly in .container */
      /* We keep the .active class logic for content-tab-panel */
    }
    .main-tab-content.active {
      display: block; /* Kept for content-tab-panel */
    }

    /* Upload & Preview Areas */
    .app-container {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .upload-area, .preview-area {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 1.5rem;
    }
    .upload-area {
      text-align: center;
      display: flex;
    }
    .drop-zone {
      border: 2px dashed #3498db;
      border-radius: 5px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
      flex: 1 1 50%;
    }
    .drop-zone:hover, .drop-zone.active {
      border-color: #2980b9;
      background-color: #f0f7fc;
    }
    .drop-zone-text {
      font-size: 1.2rem;
      color: #3498db;
      margin-bottom: 1rem;
    }
    .btn {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 0.55rem 1.5rem;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: background-color 0.2s;
    }
    .btn:hover {
      background-color: #2980b9;
    }
    .btn:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }
    .btn-browser {
      background-color: #f8f9fa;
      color: #3498db;
      border: 1px solid #3498db;
    }
    .btn-browser:hover {
      background-color: #e9f5fe;
    }
    #fileInput {
      display: none;
    }
    .file-info {
      text-align: left;
      padding: 0.85rem;
      border-radius: 5px;
      transition: opacity 0.3s;
      flex: 1 1 50%;
      margin: auto 20px;
    }
    .file-info.show {
      opacity: 1;
    }
    .export-options {
      background-color: white;
      padding: 0;
      float: right;
      display: inline-flex;
      margin-left: auto; /* Adjusted margin */
    }
    .form-group {
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center; /* Align items vertically */
    }
    .form-group label {
      display: block;
      font-weight: 600;
      color: #2c3e50;
      position: relative;
      margin-right: 8px; /* Increased spacing */
      white-space: nowrap; /* Prevent label wrapping */
    }
    .form-group input {
      width: auto; /* Adjust width */
      min-width: 200px; /* Set minimum width */
      padding: 0.75rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 1rem;
    }
    .alert {
      padding: 1rem;
      border-radius: 5px;
      margin-bottom: 1.5rem;
      opacity: 0;
      transition: opacity 0.3s;
      position: fixed; /* Keep alert visible */
      top: 90px; /* Position below header */
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      min-width: 300px;
      text-align: center;
    }
    .alert-success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .alert-error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .alert.show {
      opacity: 1;
    }
    .preview-content {
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      padding: 1rem;
      background-color: #f8f9fa;
      border-radius: 5px;
      font-size: 0.9rem;
      line-height: 1.5;
      min-height: 200px;
      max-height: 60vh; /* Limit max height */
      overflow-y: auto;
      border: 1px solid #ddd; /* Added border */
    }
    /* Rich Text Editor */
    #editableContent {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      white-space: normal;
      min-height: 300px;
      border: 1px solid #ddd;
      outline: none;
      padding: 1.5rem; /* Consistent padding */
      background-color: white;
      max-height: 60vh; /* Limit max height */
      overflow-y: auto;
    }
    .editor-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      padding: 0.5rem;
      background-color: #f1f3f4;
      border: 1px solid #ddd;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
    }
    .editor-toolbar button {
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 0.3rem 0.6rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .editor-toolbar button:hover {
      background-color: #e9ecef;
    }
    .editor-toolbar button.active {
      background-color: #e2f0fd;
      border-color: #3498db;
    }
    .js-editor {
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      background-color: #2d2d2d;
      color: #f8f8f2;
      border: 1px solid #444;
      padding: 1.5rem !important; /* Consistent padding */
    }
    .js-editor-toolbar, .markdown-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background-color: #333;
      border: 1px solid #444;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
    }
    .js-format-btn, .copy-markdown-btn {
      background-color: #4caf50;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .js-format-btn:hover, .copy-markdown-btn:hover {
      background-color: #45a049;
    }
    /* Toggle Switch */
    .editor-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #ddd;
      font-size: 0.9rem;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
    }
    input:checked + .slider {
      background-color: #3498db;
    }
    input:focus + .slider {
      box-shadow: 0 0 1px #3498db;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    .slider.round {
      border-radius: 24px;
    }
    .slider.round:before {
      border-radius: 50%;
    }
    /* Content Tabs */
    .content-tabs {
      display: flex;
      align-items: center; /* Align items vertically */
      margin-bottom: 1rem;
      border-bottom: 1px solid #ddd;
    }
    .content-tab {
      padding: 0.75rem 1.5rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      white-space: nowrap; /* Prevent wrapping */
    }
    .content-tab.active {
      border-bottom-color: #3498db;
      color: #3498db;
      font-weight: 600;
    }
    .content-tab-panel {
      display: none;
    }
    .content-tab-panel.active {
      display: block;
    }
    button#exportBtn {
      position: relative;
      margin-left: 10px;
    }
    /* Additional styles for rich text content */
    #editableContent h1, #editableContent h2, #editableContent h3,
    #editableContent h4, #editableContent h5, #editableContent h6,
    #editableContent ul, #editableContent ol {
      padding-bottom: 10px;
      margin-bottom: 0.5em; /* Added margin */
    }
    #editableContent ul, #editableContent ol {
      padding-inline-start: 25px; /* Adjusted padding */
      margin-bottom: 1em; /* Added margin */
    }
    #editableContent li {
      padding-bottom: 4px; /* Increased padding */
      margin-bottom: 0.2em; /* Added margin */
    }
    /* Export type selector */
    .export-type-selector {
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .export-type-selector label {
      margin-right: 1rem;
      font-weight: 600;
    }
    /* Markdown preview styles */
    #markdownContent {
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      background-color: #f8f9fa;
      color: #333;
      border: 1px solid #ddd;
      padding: 1.5rem !important; /* Consistent padding */
      max-height: 60vh; /* Limit max height */
      overflow-y: auto;
    }
    .markdown-editor {
      font-family: 'Courier New', Courier, monospace;
      white-space: pre-wrap;
      background-color: #f8f9fa;
      color: #333;
      border: 1px solid #ddd;
      padding: 1.5rem !important; /* Consistent padding */
      max-height: 60vh; /* Limit max height */
      overflow-y: auto;
    }
    /* File dropdown styles */
    #fileDropdown {
      margin: 1rem 0;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px solid #ddd;
      width: 100%;
      max-width: 400px;
    }

    /* Knowledge Base Manager Styles (KEEP ALL FOR SCRIPT COMPATIBILITY) */
    .kb-manager-container {
      max-width: 1000px;
      margin: 0 auto;
      background-color: #f3f4f6;
      padding: 24px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .action-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-bottom: 24px;
      align-items: flex-end; /* Align items to the bottom */
    }

    .dropdown-container {
      flex: 1;
      min-width: 200px; /* Reduced min-width */
    }

    .action-buttons {
      display: flex;
      align-items: flex-end;
      gap: 8px;
      margin-left: auto; /* Push buttons to the right */
    }

    /* Base button styles */
    .kb-manager-container button {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid transparent;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        transition: background-color 0.2s, color 0.2s, border-color 0.2s;
    }

    .primary-button {
      background-color: #4f46e5;
      color: white;
    }
    .primary-button:hover {
      background-color: #4338ca;
    }
    .primary-button:disabled {
      background-color: #9ca3af;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .icon-button {
      padding: 8px;
      background: none;
      color: #4f46e5;
      border: none;
    }
    .icon-button:hover {
      color: #4338ca;
      background-color: #e0e7ff; /* Light background on hover */
    }
    .icon-button svg { /* Ensure SVG scales with button */
        width: 20px;
        height: 20px;
    }

    .red-icon-button {
      padding: 6px; /* Slightly smaller padding */
      background: none;
      color: #ef4444;
      border: none;
    }
    .red-icon-button:hover {
      color: #dc2626;
      background-color: #fee2e2; /* Light red background on hover */
    }

    .green-icon-button {
      padding: 8px;
      background-color: #10b981;
      color: white;
    }
    .green-icon-button:hover {
      background-color: #059669;
    }

    .red-button {
      padding: 8px;
      background-color: #ef4444;
      color: white;
    }
    .red-button:hover {
      background-color: #dc2626;
    }

    .section {
      background-color: white;
      padding: 16px;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
      margin-bottom: 24px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 10px; /* Add padding below header */
      border-bottom: 1px solid #e5e7eb; /* Separator line */
    }
     .section-header h2 {
        margin-bottom: 0; /* Remove default h2 margin */
     }
     .section-header .icon-button span {
         margin-left: 4px; /* Space between icon and text */
     }

    .category-form {
      margin-bottom: 16px;
      padding: 12px;
      background-color: #f9fafb;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }
    .category-form h3 {
        margin-bottom: 12px; /* Space below heading */
    }

    .input-group {
      display: flex;
      gap: 8px;
      align-items: center; /* Align items vertically */
    }

    .kb-manager-container input[type="text"] {
      flex: 1;
      padding: 8px 10px; /* Adjusted padding */
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14px;
    }

    .category-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 12px; /* Increased gap */
    }

    .category-item {
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      overflow: hidden;
      background-color: white; /* Ensure white background */
    }

    .category-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px; /* Consistent padding */
      background-color: #f9fafb;
      cursor: pointer;
      border-bottom: 1px solid #e5e7eb; /* Separator */
    }
    .category-header:hover {
        background-color: #f3f4f6; /* Slight hover effect */
    }
    .category-name {
        font-weight: 600; /* Make name bold */
        color: #1f2937;
    }

    .category-header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .chevron-icon {
        transition: transform 0.2s ease-in-out; /* Smooth transition */
    }
    .category-content.hidden + .category-header .chevron-icon {
        /* Keep default state when hidden */
    }
    .category-content:not(.hidden) + .category-header .chevron-icon {
         transform: rotate(180deg); /* Rotate when open */
    }


    .category-content {
      padding: 16px; /* Consistent padding */
      background-color: white;
    }

    .kb-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px; /* Increased margin */
    }
    .kb-header h4 {
        margin-bottom: 0; /* Remove default h4 margin */
        font-size: 14px;
        font-weight: 600;
        color: #374151;
    }
     .kb-header .icon-button span {
         margin-left: 4px; /* Space between icon and text */
     }

    .kb-form {
      margin-bottom: 16px; /* Increased margin */
      padding: 12px; /* Increased padding */
      background-color: #f9fafb;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }

    .kb-list {
      list-style: none;
      padding: 0;
      margin: 0; /* Remove default margin */
      display: flex;
      flex-direction: column;
      gap: 6px; /* Adjusted gap */
    }
    /* Target KB list within a category */
    .category-kb-list {
        margin-top: 8px; /* Add space above list in category */
        min-height: 30px; /* Minimum height for drop target visibility */
        padding: 8px; /* Padding for drop area */
        border: 1px dashed transparent; /* Placeholder for dragover */
        border-radius: 4px;
    }


    .kb-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px; /* Adjusted padding */
      font-size: 14px;
      background-color: #f9fafb;
      border: 1px solid #e5e7eb; /* Add border */
      border-radius: 6px;
    }
    /* Style for KB items in the 'All Knowledge Bases' list */
     #all-kb-list .kb-item {
        background-color: white; /* Different background */
     }


    /* Drag and drop styles */
    .kb-item.draggable {
      cursor: grab;
    }
    .kb-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
      background-color: #e0e7ff; /* Highlight while dragging */
      border-color: #a5b4fc;
    }
    .kb-item.draggable:hover {
      background-color: #eff6ff; /* Light blue hover */
      border-color: #bfdbfe;
    }
    .category-kb-list.dragover {
      background-color: #eff6ff; /* Highlight drop zone */
      border: 1px dashed #93c5fd;
    }

    .kb-badge {
      display: inline-block;
      padding: 2px 8px; /* Increased padding */
      background-color: #e5e7eb;
      border-radius: 12px; /* Pill shape */
      margin-right: 6px; /* Increased margin */
      font-size: 12px;
      font-weight: 500;
      color: #4b5563;
    }

    .icon {
      width: 20px;
      height: 20px;
    }
    .icon-sm {
      width: 18px; /* Adjusted size */
      height: 18px;
    }
    .icon-xs {
      width: 14px;
      height: 14px;
    }

    .hidden {
      display: none !important; /* Use important to override potential conflicts */
    }

    .text-gray {
      color: #6b7280;
      font-style: italic;
      text-align: center; /* Center placeholder text */
      padding: 16px; /* Add padding */
    }

    .kb-categories {
      margin-left: 12px; /* Increased margin */
      font-size: 12px;
      color: #6b7280;
      display: flex; /* Use flex for badges */
      flex-wrap: wrap;
      gap: 4px;
    }

    .drag-handle {
      cursor: grab;
      margin-right: 8px;
      color: #9ca3af;
      display: flex; /* Center icon */
      align-items: center;
    }
    .drag-handle svg { /* Ensure handle icon size */
        width: 16px;
        height: 16px;
    }


    .kb-info-container {
      display: flex;
      align-items: center;
      flex: 1;
      overflow: hidden; /* Prevent long names from breaking layout */
    }
    .kb-name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis; /* Add ellipsis for long names */
        margin-right: 8px; /* Space before categories/buttons */
    }

    .kb-manager-container h2 {
      font-size: 18px;
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 0; /* Reset margin, handled by section-header */
    }
    .kb-manager-container h3 {
      font-size: 16px; /* Slightly larger */
      font-weight: 600; /* Bolder */
      margin-bottom: 8px;
      color: #111827;
    }
     .kb-manager-container h4 {
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 8px;
     }

    .kb-manager-container select {
      width: 100%;
      padding: 10px;
      background-color: white;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      font-size: 14px; /* Consistent font size */
    }

    .kb-manager-container label {
      display: block;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 6px; /* Increased margin */
      color: #374151; /* Darker label color */
    }

    /* Ensure icons inside buttons look good */
    .kb-manager-container button svg {
        vertical-align: middle;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="headerArea">
      <h1>Knowledge Base Editor (.DOCX to .JS/Markdown)</h1>
    </div>

    <!-- Global Alert Box -->
    <div id="alertBox" class="alert"></div>

    <!-- Editor Section (Content from original #editor-tab) -->
    <div id="editor-content-wrapper" class="content-wrapper"> <!-- Added wrapper for layout -->
      <select id="fileDropdown">
        <option value="">Select a kb_*.js file to edit</option>
      </select>
      <div class="app-container">
        <div class="upload-area">
          <div id="dropZone" class="drop-zone">
            <i class="fas fa-cloud-upload-alt" style="font-size:32px;"></i>
            <p class="drop-zone-text">Drag & Drop your DOCX file here</p>
            <button id="browseBtn" class="btn btn-browser">Browse Files</button>
            <input type="file" id="fileInput" accept=".docx" />
          </div>
          <div id="fileInfo" class="file-info">
            <h3>File Information</h3>
            <p id="fileName">No file selected</p>
            <p id="fileSize"></p>
          </div>
        </div>
        <div class="preview-area">
          <div class="content-tabs">
            <div class="content-tab active" data-content-tab="original">Original Content</div>
            <div class="content-tab" data-content-tab="markdown">Markdown</div>
            <div class="content-tab" data-content-tab="converted">Converted JS</div>
            <!-- Export Options moved inside -->
            <div class="export-options">
              <div class="form-group">
                <label for="outputFileName">Name:</label>
                <input type="text" id="outputFileName" placeholder="kb_knowledge-base.js" value="kb_knowledge-base.js" />
              </div>
              <button id="exportBtn" class="btn" disabled>Export</button>
            </div>
          </div>
          <div id="originalContent" class="content-tab-panel active">
            <div class="editor-toolbar">
              <button type="button" data-command="bold" title="Bold"><b>B</b></button>
              <button type="button" data-command="italic" title="Italic"><i>I</i></button>
              <button type="button" data-command="underline" title="Underline"><u>U</u></button>
              <button type="button" data-command="formatBlock" data-value="H1" title="Heading 1">H1</button>
              <button type="button" data-command="formatBlock" data-value="H2" title="Heading 2">H2</button>
              <button type="button" data-command="formatBlock" data-value="H3" title="Heading 3">H3</button>
              <button type="button" data-command="formatBlock" data-value="H4" title="Heading 4">H4</button>
              <button type="button" data-command="formatBlock" data-value="H5" title="Heading 5">H5</button>
              <button type="button" data-command="formatBlock" data-value="H6" title="Heading 6">H6</button>
              <button type="button" data-command="insertUnorderedList" title="Bullet List">• List</button>
              <button type="button" data-command="insertOrderedList" title="Numbered List">1. List</button>
              <button type="button" data-command="justifyLeft" title="Align Left"><i class="material-icons">format_align_left</i></button>
              <button type="button" data-command="justifyCenter" title="Align Center"><i class="material-icons">format_align_center</i></button>
              <button type="button" data-command="justifyRight" title="Align Right"><i class="material-icons">format_align_right</i></button>
              <button type="button" data-command="removeFormat" title="Clear Formatting"><i class="material-icons">format_clear</i></button>
            </div>
            <div class="preview-content" id="editableContent" contenteditable="true">
              No content to preview yet. Please upload a DOCX file or select a JS file from dropdown.
            </div>
          </div>
          <div id="markdownContent" class="content-tab-panel">
            <div class="markdown-toolbar">
              <button type="button" class="copy-markdown-btn" title="Copy Markdown">Copy Markdown</button>
            </div>
            <div class="preview-content markdown-editor" contenteditable="true">
              No markdown content yet.
            </div>
          </div>
          <div id="convertedContent" class="content-tab-panel">
            <div class="js-editor-toolbar">
              <button type="button" class="js-format-btn" title="Format JS">Format Code</button>
              <div class="editor-toggle">
                <span>Auto-update from content:</span>
                <label class="switch">
                  <input type="checkbox" id="autoUpdateToggle" checked>
                  <span class="slider round"></span>
                </label>
              </div>
            </div>
            <div class="preview-content js-editor" contenteditable="true">
              No converted content yet.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Knowledge Base Manager Templates (Keep for script compatibility) -->
    <template id="category-template">
      <li class="category-item" data-id="">
        <div class="category-header">
          <span class="category-name"></span>
          <div class="category-header-actions">
            <button class="remove-category-button red-icon-button" title="Remove Category">
              <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
              </svg>
            </button>
            <svg class="chevron-icon icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="6 9 12 15 18 9"></polyline> <!-- Initial state: pointing down -->
            </svg>
          </div>
        </div>

        <div class="category-content hidden"> <!-- Start hidden -->
          <div class="kb-header">
            <h4>Knowledge Bases in this Category</h4>
          </div>

          <ul class="kb-list category-kb-list" data-category-id="">
            <!-- KBs will be dynamically inserted here -->
          </ul>

          <p class="no-kbs text-gray hidden">No knowledge bases in this category. Use the assignment dropdown above to add.</p>
        </div>
      </li>
    </template>

    <template id="kb-template">
      <li class="kb-item draggable" data-id="" draggable="true">
        <div class="kb-info-container">
          <span class="drag-handle" title="Drag to reorder or move to another category">
            <svg class="icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="8" y1="6" x2="21" y2="6"></line>
              <line x1="8" y1="12" x2="21" y2="12"></line>
              <line x1="8" y1="18" x2="21" y2="18"></line>
              <line x1="3" y1="6" x2="3.01" y2="6"></line>
              <line x1="3" y1="12" x2="3.01" y2="12"></line>
              <line x1="3" y1="18" x2="3.01" y2="18"></line>
            </svg>
          </span>
          <span class="kb-name"></span>
        </div>
        <button class="remove-kb-button red-icon-button" title="Remove from this Category">
          <svg class="icon-xs" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line> <!-- Changed to simple 'X' -->
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </li>
    </template>

    <template id="all-kb-template">
      <li class="kb-item" data-id="">
        <div class="kb-info-container">
          <span class="kb-name"></span>
          <div class="kb-categories"> <!-- Container for category badges -->
              <!-- Badges added dynamically -->
          </div>
        </div>
        <!-- No actions needed in the 'All KBs' list -->
      </li>
    </template>

  </div>

  <!-- Include Mammoth.js for DOCX parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.17/mammoth.browser.min.js"></script>
  <!-- Include Turndown.js for HTML to Markdown conversion -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turndown/7.1.1/turndown.min.js"></script>
  <script>
document.addEventListener('DOMContentLoaded', function () {
  // ===============================
  // GLOBAL VARIABLES
  // ===============================
  
  // State variables
  let currentFileSource = null; // 'upload' or 'dropdown'
  let currentJsObject = null;
  let currentMarkdownContent = null;
  let docxContent = null;
  let isAutoUpdateEnabled = true;
  let documentTitle = '';
  let documentName = '';
  let documentCategory = '';
  let loadedJsFilename = null;
  let existingFiles = new Set();
  let confluencePageId = null;
  let confluenceBearerToken = null;
  let confluenceBaseUrl = 'https://confluence.prod.aws.jpmchase.net/confluence'; // Default value, can be changed for different environments

  // DOM Elements
  const dropZone = document.getElementById('dropZone');
  const fileInput = document.getElementById('fileInput');
  const browseBtn = document.getElementById('browseBtn');
  const fileInfo = document.getElementById('fileInfo');
  const fileName = document.getElementById('fileName');
  const fileSize = document.getElementById('fileSize');
  const editableContent = document.getElementById('editableContent');
  const autoUpdateToggle = document.getElementById('autoUpdateToggle');
  const outputFileName = document.getElementById('outputFileName');
  const exportBtn = document.getElementById('exportBtn');
  const alertBox = document.getElementById('alertBox');
  const fileDropdown = document.getElementById('fileDropdown');
  const copyMarkdownBtn = document.querySelector('.copy-markdown-btn');
  const markdownEditor = document.querySelector('.markdown-editor');
  const jsEditorElement = document.querySelector('.js-editor');
  const jsFormatBtn = document.querySelector('.js-format-btn');
  const editorToolbar = document.querySelector('.editor-toolbar');
  const contentTabs = document.querySelectorAll('.content-tab');

  // ===============================
  // CONFLUENCE API INTEGRATION FUNCTIONS
  // ===============================
  
  /**
   * Extract page ID from Confluence meta tags
   * Looks for <meta name="ajs-page-id" content="[pageId]">
   */
  function extractConfluencePageId() {
    try {
      console.log('Attempting to extract Confluence page ID from meta tags...');
      
      // Check if we're in an iframe
      if (window.parent && window.parent !== window) {
        try {
          // Try to access parent frame (might fail due to same-origin policy)
          const parentMeta = window.parent.document.querySelector('meta[name="ajs-page-id"]');
          if (parentMeta) {
            const pageId = parentMeta.getAttribute('content');
            console.log(`Found page ID in parent frame: ${pageId}`);
            return pageId;
          }
        } catch (e) {
          console.log('Could not access parent frame due to same-origin policy');
        }
      }
      
      // Check in current document
      const meta = document.querySelector('meta[name="ajs-page-id"]');
      if (meta) {
        const pageId = meta.getAttribute('content');
        console.log(`Found page ID in current document: ${pageId}`);
        return pageId;
      }
      
      // If we're in a Confluence page but can't find the meta tag
      if (window.location.href.includes('confluence')) {
        // Try to extract from URL - common Confluence URL pattern
        const matches = window.location.href.match(/\/pages\/(\d+)\//);
        if (matches && matches[1]) {
          console.log(`Extracted page ID from URL: ${matches[1]}`);
          return matches[1];
        }
        
        // Another pattern
        const viewPageMatches = window.location.href.match(/pageId=(\d+)/);
        if (viewPageMatches && viewPageMatches[1]) {
          console.log(`Extracted page ID from URL query param: ${viewPageMatches[1]}`);
          return viewPageMatches[1];
        }
      }
      
      console.log('Could not find Confluence page ID');
      return null;
    } catch (error) {
      console.error('Error extracting page ID:', error);
      return null;
    }
  }

  /**
   * Get or extract bearer token from meta tag or local storage
   * Note: This uses the same meta tag as page ID, assuming the content is used as token
   */
  function getBearerToken() {
    try {
      console.log('Attempting to extract bearer token from meta tags...');
      
      // Check if we're in an iframe
      if (window.parent && window.parent !== window) {
        try {
          // Try to access parent frame (might fail due to same-origin policy)
          const parentMeta = window.parent.document.querySelector('meta[name="ajs-page-id"]');
          if (parentMeta) {
            const token = parentMeta.getAttribute('content');
            console.log('Found bearer token in parent frame');
            return token;
          }
        } catch (e) {
          console.log('Could not access parent frame due to same-origin policy');
        }
      }
      
      // Check in current document
      const meta = document.querySelector('meta[name="ajs-page-id"]');
      if (meta) {
        const token = meta.getAttribute('content');
        console.log('Found bearer token in current document');
        return token;
      }
      
      console.log('Could not find bearer token');
      return null;
    } catch (error) {
      console.error('Error extracting bearer token:', error);
      return null;
    }
  }
  
  /**
   * Get authentication headers for Bearer Token authentication
   */
  function getAuthHeaders() {
    if (!confluenceBearerToken) {
      confluenceBearerToken = getBearerToken();
      if (!confluenceBearerToken) {
        throw new Error('Bearer token is required for Confluence API access');
      }
    }
    
    return {
      'Authorization': `Bearer ${confluenceBearerToken}`,
      'X-Atlassian-Token': 'no-check'
    };
  }
  
  /**
   * Construct properly formatted Confluence API URL
   */
  function constructApiUrl(baseUrl, endpoint) {
    // Remove trailing slashes from baseUrl
    const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
    // Remove leading slashes from endpoint
    const cleanEndpoint = endpoint.replace(/^\/+/, '');
    
    return `${cleanBaseUrl}/${cleanEndpoint}`;
  }
  
  /**
   * Get list of attachments from Confluence
   */
  async function listAttachments() {
    try {
      console.log('Fetching attachment list from Confluence...');
      
      // Ensure we have a page ID
      if (!confluencePageId) {
        confluencePageId = extractConfluencePageId();
        if (!confluencePageId) {
          throw new Error('Could not determine Confluence page ID');
        }
      }
      
      // Construct proper API URL for listing attachments
      const listApiUrl = constructApiUrl(confluenceBaseUrl, `rest/api/content/${confluencePageId}/child/attachment`);
      console.log(`List API URL: ${listApiUrl}`);
      
      // Get authentication headers
      const headers = getAuthHeaders();
      
      // Get list of attachments
      const listResponse = await fetch(listApiUrl, {
        method: 'GET',
        headers: {
          ...headers,
          'Accept': 'application/json'
        }
      });
      
      console.log(`List response status: ${listResponse.status} ${listResponse.statusText}`);
      
      if (!listResponse.ok) {
        const errorText = await listResponse.text();
        console.error('List response error details:', errorText);
        throw new Error(`Failed to get attachments list: ${listResponse.status} ${listResponse.statusText}`);
      }
      
      const attachments = await listResponse.json();
      console.log(`Found ${attachments.results.length} attachments`);
      
      // Log first attachment to see the structure
      if (attachments.results.length > 0) {
        console.log('First attachment structure:', JSON.stringify(attachments.results[0], null, 2));
      }
      
      return attachments.results;
    } catch (error) {
      console.error('Error listing attachments:', error);
      throw error;
    }
  }
  
  /**
   * Get a JS file from Confluence attachments - Updated with specific patterns
   */
  async function getJsFileFromConfluence(filename) {
    try {
      console.log(`Retrieving file '${filename}' from Confluence...`);
      
      // Ensure we have a page ID
      if (!confluencePageId) {
        confluencePageId = extractConfluencePageId();
        if (!confluencePageId) {
          throw new Error('Could not determine Confluence page ID');
        }
      }
      
      // Get authentication headers
      const headers = getAuthHeaders();
      
      // First, get the list of attachments to find the one we want
      const attachments = await listAttachments();
      const attachment = attachments.find(att => att.title === filename);
      
      if (!attachment) {
        throw new Error(`Attachment "${filename}" not found on this page`);
      }
      
      const attachmentId = attachment.id;
      console.log(`Found attachment with ID: ${attachmentId}`);

      // Generate URL patterns to try
      const urlPatterns = [
        // Standard patterns
        `${confluenceBaseUrl}/rest/api/content/${attachmentId}/data`,
        `${confluenceBaseUrl}/rest/api/content/${confluencePageId}/child/attachment/${attachmentId}/data`,
        `${confluenceBaseUrl}/download/attachments/${confluencePageId}/${attachmentId}`,
        
        // specific patterns
        `${confluenceBaseUrl}/download/attachments/${confluencePageId}/${attachmentId}/${filename}`,
        `${confluenceBaseUrl}/download/attachments/${confluencePageId}/${filename}`,
        `${confluenceBaseUrl}/rest/api/content/${confluencePageId}/child/attachment/${attachmentId}/download`,
        `${confluenceBaseUrl}/plugins/servlet/confluence/placeholder/attachment?pageId=${confluencePageId}&fileName=${filename}`,
        
        // Some enterprises use servlets
        `${confluenceBaseUrl}/plugins/servlet/confluence/file/${confluencePageId}/${attachmentId}`,
        
        // Legacy pattern
        `${confluenceBaseUrl}/download/attachments/${confluencePageId}/${encodeURIComponent(filename)}`
      ];
      
      let content = null;
      let successUrl = null;
      let errorDetails = [];
      
      // Try each URL pattern until one works
      for (const url of urlPatterns) {
        try {
          console.log(`Trying URL: ${url}`);
          
          const response = await fetch(url, {
            method: 'GET',
            headers: headers
          });
          
          console.log(`Response status for ${url}: ${response.status} ${response.statusText}`);
          
          if (response.ok) {
            // Try to get the content type
            const contentType = response.headers.get('content-type');
            console.log(`Content type: ${contentType}`);
            
            // Get the content as text
            content = await response.text();
            successUrl = url;
            console.log(`Successfully retrieved content (${content.length} bytes)`);
            break;
          } else {
            // Store error details for debugging
            const errorText = await response.text();
            errorDetails.push({
              url: url,
              status: response.status,
              statusText: response.statusText,
              errorText: errorText
            });
          }
        } catch (innerError) {
          console.log(`Failed with URL ${url}: ${innerError.message}`);
          errorDetails.push({
            url: url,
            error: innerError.message
          });
          // Continue to the next URL pattern
        }
      }
      
      if (!content) {
        console.error('All download attempts failed. Error details:', JSON.stringify(errorDetails, null, 2));
        throw new Error('All attachment download URL patterns failed. Verify permissions and attachment ID.');
      }
      
      console.log(`File retrieved successfully using: ${successUrl}`);
      return content;
    } catch (error) {
      console.error('Error retrieving file:', error);
      throw error;
    }
  }

  /**
   * Upload a .js file to Confluence as an attachment
   * Supports overwriting existing files
   */
  async function uploadJsFileToConfluence(fileName, fileContent) {
    try {
      console.log(`Uploading file ${fileName} to Confluence...`);
      
      // Ensure we have a page ID
      if (!confluencePageId) {
        confluencePageId = extractConfluencePageId();
        if (!confluencePageId) {
          throw new Error('Could not determine Confluence page ID');
        }
      }
      
      // Check if file with the same name already exists
      const attachments = await listAttachments();
      const existingAttachment = attachments.find(att => att.title === fileName);
      
      // Construct proper API URL
      let apiUrl;
      let method;
      
      if (existingAttachment) {
        // Use update endpoint with attachment ID for overwriting
        apiUrl = constructApiUrl(confluenceBaseUrl, `rest/api/content/${confluencePageId}/child/attachment/${existingAttachment.id}/data`);
        method = 'POST'; // Some Confluence instances use POST for updates too
        console.log(`Existing file found, will overwrite ${fileName} with ID: ${existingAttachment.id}`);
      } else {
        // Use standard endpoint for new attachments
        apiUrl = constructApiUrl(confluenceBaseUrl, `rest/api/content/${confluencePageId}/child/attachment`);
        method = 'POST';
        console.log(`No existing file found, uploading new file ${fileName}`);
      }
      
      console.log(`API URL: ${apiUrl}`);
      
      // Get authentication headers
      const headers = getAuthHeaders();
      console.log('Headers prepared (auth details hidden)');
      
      // Create blob from file content
      const blob = new Blob([fileContent], { type: 'application/javascript' });
      console.log(`Created blob with size: ${blob.size} bytes`);
      
      // Create FormData and append file
      const formData = new FormData();
      formData.append('file', blob, fileName);
      
      // Make API request
      console.log(`Sending ${method} request...`);
      const response = await fetch(apiUrl, {
        method: method,
        headers: headers,
        body: formData
      });
      
      console.log(`Response status: ${response.status} ${response.statusText}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Response error details:', errorText);
        throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log('Upload successful:', data);
      return data;
    } catch (error) {
      console.error('Error uploading file:', error);
      throw error;
    }
  }

  // ===============================
  // UTILITY FUNCTIONS
  // ===============================
  
  // Prevent default event behavior
  function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
  }

  // Format file size into human-readable string
  function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }

  // Show alert notification
  function showAlert(message, type = 'info', duration = 4000) {
    if (!alertBox) {
      console.warn("Alert box element not found. Cannot show alert:", message);
      console.log(`${type.toUpperCase()}: ${message}`);
      return;
    }

    alertBox.textContent = message;
    alertBox.className = `alert alert-${type} show`;
    
    // Ensure alert is visible
    alertBox.style.opacity = "1";
    alertBox.style.zIndex = "2000";
    
    // Clear previous timeouts
    if (alertBox.timeoutId) {
      clearTimeout(alertBox.timeoutId);
    }
    
    alertBox.timeoutId = setTimeout(() => {
      alertBox.classList.remove('show');
      alertBox.timeoutId = null;
    }, duration);
  }

  // Copy text to clipboard
  function copyToClipboard(text) {
    navigator.clipboard.writeText(text)
      .then(() => showAlert('Content copied to clipboard!', 'success'))
      .catch(error => {
        console.error('Error copying to clipboard:', error);
        showAlert('Error copying to clipboard.', 'error');
      });
  }

  // ===============================
  // FILE HANDLING FUNCTIONS
  // ===============================
  
  // Fallback direct download if Confluence attachment fails
  function offerDirectDownload(file) {
    console.log("Offering direct download as fallback");
    showAlert("Could not automatically save to Confluence. Preparing download instead.", "info");
    
    try {
      // Create download link
      const downloadLink = document.createElement('a');
      downloadLink.href = URL.createObjectURL(file);
      downloadLink.download = file.name;
      downloadLink.style.display = 'none';
      document.body.appendChild(downloadLink);
      
      // Trigger download
      downloadLink.click();
      
      // Clean up
      setTimeout(() => {
        URL.revokeObjectURL(downloadLink.href);
        document.body.removeChild(downloadLink);
        showAlert(`Download prepared for '${file.name}'. Please manually upload to Confluence.`, 'success');
      }, 100);
    } catch (error) {
      console.error("Direct download fallback failed:", error);
      showAlert("Could not prepare download. Check console for details.", "error");
    }
  }

  // Handle file drop on drop zone
  function handleDrop(e) {
    const dt = e.dataTransfer;
    const files = dt.files;
    handleFiles({ target: { files } });
  }

  // Process files from input or drop
  function handleFiles(e) {
    const files = e.target.files;
    if (files.length > 0) {
      const file = files[0];
      resetEditorState(); // Clear previous state
      if (file.name.endsWith('.docx')) {
        const baseName = file.name.replace(/\.docx$/i, '');
        // Standardize kb file naming convention
        outputFileName.value = `kb_${baseName.toLowerCase().replace(/[^a-z0-9_]+/g, '_')}.js`;
        processDocxFile(file);
        currentFileSource = 'upload';
      } else {
        showAlert('Please upload a .docx file.', 'error');
        resetEditorState(true); // Also clear file info
      }
      // Reset file input value to allow uploading the same file again
      if (fileInput) fileInput.value = null;
    }
  }

  // Populate dropdown with kb_*.js files from Confluence attachments
  async function populateFileDropdown() {
    if (!fileDropdown) {
      console.warn("Editor file dropdown element not found. Skipping population.");
      return;
    }
    console.log("Populating editor file dropdown...");
    // Clear existing options except the first placeholder
    while (fileDropdown.options.length > 1) {
      fileDropdown.remove(1);
    }
    existingFiles.clear(); // Reset tracked files

    try {
      // Get attachments from Confluence API
      const attachments = await listAttachments();
      let fileCount = 0;
      
      // Filter for kb_*.js files
      const jsFiles = attachments.filter(att => 
        att.title && att.title.startsWith('kb_') && att.title.endsWith('.js')
      );
      
      // Add each file to dropdown
      jsFiles.forEach(attachment => {
        addToFileDropdown(attachment.title);
        fileCount++;
      });
      
      console.log(`Added ${fileCount} kb_*.js files to the dropdown.`);
    } catch (error) {
      console.error('Error populating dropdown:', error);
      showAlert('Failed to load files from Confluence. Check console for details.', 'error');
    }
  }

  // Add a single file to the editor dropdown if it's not already there
  function addToFileDropdown(filename) {
    if (!fileDropdown) return; // Check if element exists
    
    // Check if the file already exists in the dropdown
    let fileExists = false;
    for (let i = 0; i < fileDropdown.options.length; i++) {
      if (fileDropdown.options[i].value === filename) {
        fileExists = true;
        break;
      }
    }
    
    // Only add if not already present
    if (!fileExists) {
      console.log(`Adding new file to dropdown: ${filename}`);
      const option = document.createElement('option');
      option.value = filename;
      option.textContent = filename;
      fileDropdown.appendChild(option);
      existingFiles.add(filename); // Track it
    }
  }

  // Load JS file content from Confluence API
  async function loadJSFileContent(filename) {
    if (!editableContent || !jsEditorElement || !outputFileName || !exportBtn || !fileInfo) return; // Check elements

    console.log(`Loading JS file: ${filename}`);
    loadedJsFilename = filename; // Track loaded file
    showAlert(`Loading ${filename}...`, 'info', 2000);

    try {
      const jsContent = await getJsFileFromConfluence(filename);
      
      if (!jsContent) {
        throw new Error("Received empty content.");
      }
      console.log(`Content loaded for ${filename}. Length: ${jsContent.length}`);
      jsEditorElement.textContent = jsContent; // Show raw content in JS view first

      const extractedData = extractDataFromJsCode(jsContent);
      console.log("Extracted data:", extractedData);

      if (extractedData.type === 'llmPrimer') {
        currentMarkdownContent = extractedData.content;
        currentJsObject = { // Create a basic JS object representation
          name: extractedData.name,
          title: extractedData.name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()), // Infer title
          category: '', // Category not stored in llmPrimer, leave empty
          content: '' // Will be populated by markdown->html conversion
        };
        documentName = currentJsObject.name; // Update global var if needed

        // Convert Markdown to HTML for the rich text editor
        const htmlContent = markdownToHtml(currentMarkdownContent);
        editableContent.innerHTML = htmlContent;
        currentJsObject.content = htmlContent; // Store HTML in object

        // Update Markdown view
        markdownEditor.textContent = currentMarkdownContent;

        // Switch to the original content tab by default when loading
        contentTabs.forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.content-tab-panel').forEach(c => c.classList.remove('active'));
        document.querySelector('.content-tab[data-content-tab="original"]').classList.add('active');
        document.getElementById('originalContent').classList.add('active');
      } else {
        // Handle other potential types if needed in the future
        throw new Error("Loaded JS file is not in the expected llmPrimerRegister format.");
      }

      outputFileName.value = filename; // Ensure filename matches loaded file
      exportBtn.disabled = false;
      exportBtn.textContent = 'Save'; // Change button text to 'Save'
      fileInfo.classList.remove('show'); // Hide DOCX info area

      showAlert(`JS File '${filename}' loaded successfully!`, 'success');
    } catch (error) {
      console.error(`Error loading JS file '${filename}':`, error);
      editableContent.innerHTML = `<p>Error displaying content. Invalid or unsupported JS file format.<br><i>${error.message}</i></p>`;
      if (markdownEditor) markdownEditor.textContent = "Error processing JS file.";
      if (jsEditorElement) jsEditorElement.textContent = error.message; // Show error in JS view
      showAlert(`Error loading JS File '${filename}': ${error.message}`, 'error', 6000);
      exportBtn.disabled = true; // Disable saving if processing failed
      resetEditorState(true); // Clear everything on load failure
    }
  }

  // Reset editor state (clears content areas, variables)
  function resetEditorState(clearFileInfo = false) {
    console.log("Resetting editor state...");
    // Check if elements exist before trying to modify them
    if (editableContent) editableContent.innerHTML = 'No content to preview yet. Please upload a DOCX file or select a JS file from dropdown.';
    if (jsEditorElement) jsEditorElement.textContent = 'No converted content yet.';
    if (markdownEditor) markdownEditor.textContent = 'No markdown content yet.';
    docxContent = null;
    currentJsObject = null;
    currentMarkdownContent = null;
    documentTitle = '';
    documentName = '';
    documentCategory = '';
    loadedJsFilename = null; // Clear loaded filename track
    currentFileSource = null;
    if (exportBtn) {
      exportBtn.disabled = true;
      exportBtn.textContent = 'Export';
    }

    if (clearFileInfo && fileInfo && fileName && fileSize) {
      fileInfo.classList.remove('show');
      fileName.textContent = 'No file selected';
      fileSize.textContent = '';
    }
  }

  // ===============================
  // CONTENT PROCESSING FUNCTIONS
  // ===============================
  
  // Process DOCX file
  function processDocxFile(file) {
    if (!editableContent || !fileInfo || !fileName || !fileSize || !exportBtn) return; // Check if elements exist

    console.log("Processing DOCX file:", file.name);
    fileInfo.classList.add('show');
    fileName.textContent = `File: ${file.name}`;
    fileSize.textContent = `Size: ${formatBytes(file.size)}`;
    editableContent.innerHTML = '<p><i>Processing DOCX...</i></p>'; // Provide feedback

    const reader = new FileReader();
    reader.onload = function (e) {
      const arrayBuffer = e.target.result;
      const styleMap = [
        "p[style-name='Title'] => h1:fresh", // Use :fresh to ensure it's always a new h1
        "p[style-name='Heading 1'] => h1:fresh",
        "p[style-name='Heading 2'] => h2:fresh",
        "p[style-name='Heading 3'] => h3:fresh",
        "p[style-name='Heading 4'] => h4:fresh",
        "p[style-name='Heading 5'] => h5:fresh",
        "p[style-name='Heading 6'] => h6:fresh",
        "p[style-name='List Paragraph'] => li:fresh", // Map list paragraphs to li
        "r[style-name='Emphasis'] => em", // Handle character style
        "r[style-name='Strong'] => strong", // Handle character style
        "b => strong", // Map bold
        "i => em"      // Map italic
      ];

      mammoth.convertToHtml({ arrayBuffer: arrayBuffer }, { styleMap: styleMap })
        .then(result => {
          docxContent = result.value; // Store original HTML
          console.log("Mammoth HTML Output:", docxContent);
          // Clean up potential empty paragraphs Mammoth might leave
          let cleanedHtml = docxContent.replace(/<p>\s*<\/p>/gi, '');
          editableContent.innerHTML = cleanedHtml;

          // Process the content immediately
          processEditorContent();

          exportBtn.disabled = false;
          exportBtn.textContent = 'Export'; // Changed from Save initially
          showAlert('DOCX loaded successfully! Review and edit before exporting.', 'success');
        })
        .catch(error => {
          console.error('Error converting docx:', error);
          showAlert('Error processing DOCX file. Check console for details.', 'error');
          editableContent.innerHTML = '<p>Error loading DOCX content.</p>';
        });
    };
    reader.onerror = (error) => {
      console.error("FileReader error:", error);
      showAlert("Error reading the DOCX file.", "error");
      editableContent.innerHTML = '<p>Error reading file.</p>';
    };
    reader.readAsArrayBuffer(file);
  }

  // Central function to process editor content (HTML -> Markdown -> JS Object)
  function processEditorContent() {
    if (!editableContent || !markdownEditor || !jsEditorElement || !outputFileName) return; // Check if elements exist

    const currentHtml = editableContent.innerHTML;
    // 1. Convert HTML to Markdown
    const turndownService = new TurndownService({
      headingStyle: 'atx',
      codeBlockStyle: 'fenced',
      emDelimiter: '_',
      bulletListMarker: '-' // Consistent bullet marker
    });
    currentMarkdownContent = turndownService.turndown(currentHtml);
    markdownEditor.textContent = currentMarkdownContent; // Update Markdown view

    // 2. Extract Metadata and create JS Object from HTML
    currentJsObject = convertHtmlToJsObject(currentHtml);
    console.log("Generated JS Object:", currentJsObject);

    // 3. Generate the JS code for the JS view (always LLM Primer format)
    const llmPrimerCode = generateLlmPrimerCode(currentJsObject.name, currentMarkdownContent);
    jsEditorElement.textContent = llmPrimerCode; // Update JS view

    // Update filename based on extracted name if available and source was upload
    if (currentFileSource === 'upload' && currentJsObject.name) {
      outputFileName.value = `kb_${currentJsObject.name}.js`;
    } else if (currentFileSource === 'dropdown' && loadedJsFilename) {
      // Keep the loaded filename
      outputFileName.value = loadedJsFilename;
    }
    else if (!outputFileName.value || outputFileName.value === 'kb_knowledge-base.js') {
      // Fallback if name extraction fails or wasn't from upload
      const fallbackName = loadedJsFilename ? loadedJsFilename.replace(/\.js$/,'').replace(/^kb_/,'') : 'knowledge_base';
      outputFileName.value = `kb_${fallbackName}.js`;
    }
  }

  // Convert HTML from editor to a JS object, extracting metadata
  function convertHtmlToJsObject(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<body>${html}</body>`, 'text/html'); // Wrap in body for proper parsing
    const result = {
      title: '',
      name: '',
      category: '',
      content: html // Store the raw HTML content for now, might refine later
    };

    // Regex for metadata extraction (case-insensitive)
    const titleRegex = /#Title:\s*(.*)/i;
    const nameRegex = /#Name:\s*(.*)/i;
    const categoryRegex = /#Category:\s*(.*)/i;

    // Find potential metadata elements (usually H1 or strong P)
    const potentialMetaElements = doc.querySelectorAll('h1, h2, h3, p > strong, p > b');
    const elementsToRemove = [];

    potentialMetaElements.forEach(el => {
      const text = el.textContent.trim();
      let matched = false;

      const titleMatch = text.match(titleRegex);
      if (titleMatch && !result.title) {
        result.title = titleMatch[1].trim();
        elementsToRemove.push(el.closest('h1, h2, h3, p')); // Mark parent block for removal
        matched = true;
      }

      const nameMatch = text.match(nameRegex);
      if (nameMatch && !result.name) {
        result.name = nameMatch[1].trim().toLowerCase().replace(/[^a-z0-9_]+/g, '_'); // Sanitize name
        elementsToRemove.push(el.closest('h1, h2, h3, p'));
        matched = true;
      }

      const categoryMatch = text.match(categoryRegex);
      if (categoryMatch && !result.category) {
        result.category = categoryMatch[1].trim();
        elementsToRemove.push(el.closest('h1, h2, h3, p'));
        matched = true;
      }
    });

    // Remove extracted metadata elements from the document body before getting final content
    elementsToRemove.forEach(el => el?.remove());

    // Update result.content with cleaned HTML
    result.content = doc.body.innerHTML;

    // Fallback name generation if #Name tag wasn't found
    if (!result.name) {
      const baseFileName = (loadedJsFilename || outputFileName.value || 'knowledge_base.js')
                          .replace(/\.js$/i, '').replace(/^kb_/i, '');
      result.name = baseFileName.toLowerCase().replace(/[^a-z0-9_]+/g, '_');
      console.log("No #Name found, generated fallback name:", result.name);
    }

    // Extract Title from first H1 if #Title tag wasn't found
    if (!result.title) {
      const firstH1 = doc.querySelector('h1');
      if (firstH1) {
        result.title = firstH1.textContent.trim();
      } else {
        // Fallback title from name
        result.title = result.name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()); // Capitalize
      }
    }

    // Store extracted values globally if needed (though prefer passing object)
    documentTitle = result.title;
    documentName = result.name;
    documentCategory = result.category;

    return result;
  }

  // Generate llmPrimerRegister code (always used for JS view and export)
  function generateLlmPrimerCode(name, content) {
    const kbName = name || 'unknown_kb'; // Ensure name is present
    const escapedContent = content
      .replace(/\\/g, '\\\\') // Escape backslashes first
      .replace(/`/g, '\\`')  // Escape backticks
      .replace(/\$/g, '\\$'); // Escape dollars (for template literal safety)

    return `// Knowledge Base generated by Editor - ${new Date().toISOString()}
llmPrimerRegister('${kbName}', \`
${escapedContent}
\`);`;
  }

  // Convert markdown to HTML (Simplified)
  function markdownToHtml(markdown) {
    // Basic conversion - assumes simple markdown, might need a library for complex cases
    let html = markdown
      .replace(/^###### (.*$)/gim, '<h6>$1</h6>')
      .replace(/^##### (.*$)/gim, '<h5>$1</h5>')
      .replace(/^#### (.*$)/gim, '<h4>$1</h4>')
      .replace(/^### (.*$)/gim, '<h3>$1</h3>')
      .replace(/^## (.*$)/gim, '<h2>$1</h2>')
      .replace(/^# (.*$)/gim, '<h1>$1</h1>')
      .replace(/^\* (.*$)/gim, '<li>$1</li>') // Basic unordered list
      .replace(/^\d+\. (.*$)/gim, '<li>$1</li>') // Basic ordered list (no number tracking)
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
      .replace(/__(.*?)__/g, '<strong>$1</strong>') // Bold (alt)
      .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
      .replace(/_(.*?)_/g, '<em>$1</em>'); // Italic (alt)

    // Wrap list items
    html = html.replace(/<li>.*?<\/li>/gs, (match) => `<ul>${match}</ul>`).replace(/<\/ul>\s*<ul>/g, ''); // Naive wrap
    // Paragraphs (split by double newline, then wrap non-list/heading lines)
    return html.split(/\n\n+/).map(p => {
      const trimmed = p.trim();
      if (!trimmed) return '';
      if (trimmed.startsWith('<h') || trimmed.startsWith('<ul') || trimmed.startsWith('<ol')) {
        return p; // Already block element
      }
      return `<p>${p.replace(/\n/g, '<br>')}</p>`; // Wrap in p, convert single newlines to <br>
    }).join('\n');
  }

  // Extract JS object or markdown from JS code string
  function extractDataFromJsCode(jsCode) {
    try {
      // 1. Try to match llmPrimerRegister format
      const primerMatch = jsCode.match(/llmPrimerRegister\s*\(\s*['"]([^'"]+)['"]\s*,\s*`([\s\S]*?)`\s*\)/);
      if (primerMatch && primerMatch[1] && primerMatch[2]) {
        console.log("Extracted from llmPrimerRegister format");
        const name = primerMatch[1];
        const markdown = primerMatch[2]
          .replace(/\\`/g, '`') // Unescape backticks
          .replace(/\\\$/g, '$') // Unescape dollars
          .replace(/\\\\/g, '\\'); // Unescape backslashes
        return {
          type: 'llmPrimer',
          name: name,
          content: markdown // Markdown content
        };
      }

      // If not llmPrimer, try other formats or show error
      console.warn("JS file is not in llmPrimerRegister format. Attempting legacy parse.");
      throw new Error("Unsupported JS file format. Expected llmPrimerRegister(...)");

    } catch (error) {
      console.error("Error extracting data from JS code:", error);
      throw new Error(`Failed to extract valid data from JS code: ${error.message}`);
    }
  }

  // ===============================
  // EXPORT/SAVE FUNCTIONS
  // ===============================
  
  // Export file using Confluence API
  async function exportFile() {
    if (!currentJsObject || !currentMarkdownContent || !outputFileName || !exportBtn) {
      showAlert("Cannot export/save: Content is missing or hasn't been processed.", "error");
      console.error("Export aborted: currentJsObject or currentMarkdownContent is null/undefined.");
      return;
    }
    console.log("Export/Save initiated");

    // Ensure content is up-to-date before saving
    processEditorContent();

    // Generate the final JS content (LLM Primer)
    const kbNameForExport = currentJsObject.name || 'unnamed_kb';
    const jsContentToSave = generateLlmPrimerCode(kbNameForExport, currentMarkdownContent);

    // Final filename validation
    let finalFileName = outputFileName.value.trim();
    if (!finalFileName) {
      finalFileName = `kb_${kbNameForExport}.js`; // Generate filename if empty
      outputFileName.value = finalFileName; // Update input field
    }
    if (!finalFileName.startsWith('kb_')) {
      // Ensure the kb_ prefix, remove any existing one to avoid duplication
      finalFileName = 'kb_' + finalFileName.replace(/^kb_/i, ''); // Ensure prefix
      outputFileName.value = finalFileName; // Update with corrected name
    }
    if (!finalFileName.endsWith('.js')) {
      finalFileName += '.js'; // Ensure suffix
      outputFileName.value = finalFileName; // Update with corrected extension
    }
    
    // Check if we're creating a new file or updating existing
    const isNewFile = !loadedJsFilename || loadedJsFilename !== finalFileName;
    if (isNewFile && loadedJsFilename) {
      // We're saving with a different name than what was loaded - confirm with user
      const confirmMessage = `You're about to create a new file '${finalFileName}' instead of updating '${loadedJsFilename}'. Continue?`;
      if (!confirm(confirmMessage)) {
        console.log("File creation cancelled by user");
        return;
      }
    }

    // Disable button during save
    exportBtn.disabled = true;
    exportBtn.textContent = isNewFile ? 'Creating...' : 'Updating...';

    try {
      // Use Confluence API to upload the file
      await uploadJsFileToConfluence(finalFileName, jsContentToSave);
      
      // Update the file dropdown if this is a new file
      addToFileDropdown(finalFileName);
      
      if (isNewFile && loadedJsFilename) {
        console.log(`Creating new file '${finalFileName}' (instead of updating '${loadedJsFilename}')`);
        showAlert(`Created new file '${finalFileName}'`, 'success');
      } else if (isNewFile) {
        console.log(`Created new file '${finalFileName}'`);
        showAlert(`Created new file '${finalFileName}'`, 'success');
      } else {
        console.log(`Updated existing file '${finalFileName}'`);
        showAlert(`Updated '${finalFileName}' successfully!`, 'success');
      }
      
      loadedJsFilename = finalFileName; // Update loaded filename track
      fileDropdown.value = finalFileName; // Select the new name in dropdown
      currentFileSource = 'dropdown'; // Treat it as loaded from dropdown now
      exportBtn.textContent = 'Save'; // Keep as 'Save' after successful save
      
      // Refresh the file dropdown to ensure it's up to date
      await populateFileDropdown();
      fileDropdown.value = finalFileName; // Re-select after refresh
      
    } catch (error) {
      console.error('Error during save:', error);
      showAlert(`Error saving file: ${error.message}`, 'error');
      
      // Offer direct download as fallback
      const jsFileBlob = new Blob([jsContentToSave], { type: 'application/javascript;charset=utf-8' });
      const jsFile = new File([jsFileBlob], finalFileName, { type: 'application/javascript;charset=utf-8' });
      offerDirectDownload(jsFile);
    } finally {
      exportBtn.disabled = false;
      exportBtn.textContent = 'Save';
    }
  }

  // ===============================
  // EVENT LISTENERS
  // ===============================
  
  // Set up drag and drop event listeners
  if (dropZone) {
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, preventDefaults, false);
    });
    ['dragenter', 'dragover'].forEach(eventName => 
      dropZone.addEventListener(eventName, () => dropZone.classList.add('active'), false)
    );
    ['dragleave', 'drop'].forEach(eventName => 
      dropZone.addEventListener(eventName, () => dropZone.classList.remove('active'), false)
    );

    dropZone.addEventListener('drop', handleDrop, false);
  }

  // Browse button click
  if (browseBtn && fileInput) {
    browseBtn.addEventListener('click', () => fileInput.click());
  }

  // File input change
  if (fileInput) {
    fileInput.addEventListener('change', handleFiles);
  }

  // File dropdown change
  if (fileDropdown) {
    fileDropdown.addEventListener('change', function() {
      const selectedFileName = this.value;
      resetEditorState(); // Clear previous state
      if (selectedFileName) {
        outputFileName.value = selectedFileName; // Set filename for saving
        loadJSFileContent(selectedFileName);
        currentFileSource = 'dropdown';
      } else {
        resetEditorState(true); // Clear everything if "Select file" is chosen
      }
    });
  }

  // Auto-update toggle
  if (autoUpdateToggle) {
    autoUpdateToggle.addEventListener('change', function() {
      isAutoUpdateEnabled = this.checked;
      if (isAutoUpdateEnabled) {
        processEditorContent(); // Update immediately when enabled
      }
    });
  }

  // Update content when editable area changes
  if (editableContent) {
    editableContent.addEventListener('input', () => {
      if (isAutoUpdateEnabled) {
        // Use debounce to avoid excessive processing on rapid typing
        clearTimeout(editableContent.debounceTimer);
        editableContent.debounceTimer = setTimeout(() => {
          console.log("Debounced input event fired");
          processEditorContent();
        }, 500); // 500ms delay
      }
    });
  }

  // Format JS button
  if (jsFormatBtn) {
    jsFormatBtn.addEventListener('click', () => {
      try {
        // Re-generate the code which inherently formats it
        if(currentJsObject && currentMarkdownContent) {
          const formattedJs = generateLlmPrimerCode(currentJsObject.name, currentMarkdownContent);
          jsEditorElement.textContent = formattedJs;
          showAlert('JavaScript code formatted.', 'success');
        } else {
          showAlert('Cannot format - missing content.', 'error');
        }
      } catch (error) {
        showAlert('Error formatting JavaScript.', 'error');
        console.error("Formatting error:", error);
      }
    });
  }

  // Copy Markdown button
  if (copyMarkdownBtn && markdownEditor) {
    copyMarkdownBtn.addEventListener('click', () => {
      const markdownText = markdownEditor.textContent;
      copyToClipboard(markdownText);
    });
  }

  // Export/Save button
  if (exportBtn) {
    exportBtn.addEventListener('click', exportFile);
  }

  // Content tab switching
  if (contentTabs) {
    contentTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        contentTabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        document.querySelectorAll('.content-tab-panel').forEach(c => c.classList.remove('active'));
        const tabId = tab.getAttribute('data-content-tab');
        document.getElementById(tabId + 'Content').classList.add('active');

        // If switching TO Markdown or JS, ensure content is up-to-date from HTML editor
        if (tabId === 'markdown' || tabId === 'converted') {
          if (isAutoUpdateEnabled || currentFileSource === 'upload') { // Update if auto-update or initial load
            processEditorContent();
          }
        }
      });
    });
  }

  // Editor toolbar button actions
  if (editorToolbar && editableContent) {
    editorToolbar.addEventListener('click', (e) => {
      if (e.target.tagName === 'BUTTON' || e.target.closest('button')) { // Handle icon clicks inside button
        const button = e.target.closest('button');
        const command = button.dataset.command;
        const value = button.dataset.value || null;

        if (command) {
          document.execCommand(command, false, value);
          editableContent.focus(); // Keep focus in the editor

          // Optionally update button states (e.g., bold)
          updateToolbarStates();

          // Trigger update if auto-update is on
          if (isAutoUpdateEnabled) {
            // No need to debounce here, execCommand is a single action
            processEditorContent();
          }
        }
      }
    });

    // Update toolbar button states based on selection
    function updateToolbarStates() {
      const commandsToQuery = ['bold', 'italic', 'underline', 'insertUnorderedList', 'insertOrderedList'];
      commandsToQuery.forEach(cmd => {
        const button = editorToolbar.querySelector(`button[data-command="${cmd}"]`);
        if (button) {
          try {
            if (document.queryCommandState(cmd)) {
              button.classList.add('active');
            } else {
              button.classList.remove('active');
            }
          } catch (e) {
            console.warn(`Could not query command state for ${cmd}:`, e);
            button?.classList.remove('active'); // Ensure inactive on error
          }
        }
      });
    }

    // Update toolbar state on selection change in editor
    document.addEventListener('selectionchange', () => {
      if (document.activeElement === editableContent) {
        updateToolbarStates();
      }
    });
    editableContent.addEventListener('focus', updateToolbarStates);
    editableContent.addEventListener('click', updateToolbarStates); // Also update on click
  }

  // ===============================
  // INITIALIZATION
  // ===============================
  
  // Initialize the editor
  async function initializeEditor() {
    // Try to get Confluence page ID
    confluencePageId = extractConfluencePageId();
    if (confluencePageId) {
      console.log(`Auto-detected Confluence page ID: ${confluencePageId}`);
    } else {
      console.warn("Confluence page ID not detected. Some features may not work properly.");
    }
    
    // Try to get bearer token
    confluenceBearerToken = getBearerToken();
    if (confluenceBearerToken) {
      console.log("Auto-detected bearer token.");
    } else {
      console.warn("Bearer token not detected. API access may be limited.");
    }
    
    // Populate file dropdown
    await populateFileDropdown();
    
    // Add any additional initialization here
    console.log("KB Editor initialized with Confluence API integration");
  }

  // Run initialization
  initializeEditor();
});

  </script>
</body>
</html>