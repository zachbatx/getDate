<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Formatter & Minifier</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    body {
      background-color: #f5f5f5;
      color: #333;
      line-height: 1.6;
      padding: 20px;
    }
    
    .container {
      max-width: 1000px;
      margin: 0 auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #2c3e50;
    }
    
    .options {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .operation-toggle {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      gap: 20px;
    }
    
    .operation-btn {
      padding: 10px 20px;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
      border: 1px solid #ddd;
    }
    
    .operation-btn.active {
      font-weight: bold;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    }
    
    .format-btn {
      background-color: #3498db;
      color: white;
      border-color: #2980b9;
    }
    
    .format-btn:hover {
      background-color: #2980b9;
    }
    
    .minify-btn {
      background-color: #e74c3c;
      color: white;
      border-color: #c0392b;
    }
    
    .minify-btn:hover {
      background-color: #c0392b;
    }
    
    .language-select, .indent-select {
      flex: 1;
      min-width: 150px;
    }
    
    select, button {
      padding: 10px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background-color: #fff;
      font-size: 16px;
      width: 100%;
    }
    
    button {
      background-color: #3498db;
      color: white;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #2980b9;
    }
    
    button:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    
    .action-button {
      flex: 1;
      min-width: 150px;
    }
    
    .editor-container {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    .editor-box {
      flex: 1;
      min-width: 300px;
      display: flex;
      flex-direction: column;
    }
    
    .editor-box h3 {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .editor {
      height: 400px;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      font-family: monospace;
      overflow: auto;
      width: 100%;
      resize: vertical;
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.5;
      background-color: #f8f8f8;
    }
    
    .drop-zone {
      border: 2px dashed #3498db;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .drop-zone:hover, .drop-zone.active {
      background-color: #ecf0f1;
    }
    
    .drop-zone p {
      margin: 5px 0;
    }
    
    .hidden {
      display: none;
    }
    
    .stats {
      background-color: #f8f8f8;
      padding: 15px;
      border-radius: 4px;
      margin-top: 20px;
    }
    
    .stats h3 {
      margin-bottom: 10px;
    }
    
    .copy-button {
      background-color: #2ecc71;
      padding: 5px 10px;
      font-size: 14px;
    }
    
    .copy-button:hover {
      background-color: #27ae60;
    }
    
    .copy-success {
      background-color: #27ae60;
    }
    
    @media (max-width: 768px) {
      .editor-container {
        flex-direction: column;
      }
      
      .options {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Code Formatter & Minifier</h1>
    
    <div class="operation-toggle">
      <button id="formatBtn" class="operation-btn format-btn active">Format Code</button>
      <button id="minifyBtn" class="operation-btn minify-btn">Minify Code</button>
    </div>
    
    <div class="drop-zone" id="dropZone">
      <p>Drag and drop a file here</p>
      <p>or</p>
      <p><button id="selectFileButton">Select a file</button></p>
      <input type="file" id="fileInput" class="hidden" accept=".js,.css,.html,.txt">
    </div>
    
    <div class="options">
      <div class="language-select">
        <select id="languageSelect">
          <option value="javascript">JavaScript</option>
          <option value="css">CSS</option>
          <option value="html">HTML</option>
        </select>
      </div>
      <div class="indent-select" id="indentContainer">
        <select id="indentSelect">
          <option value="2">2 spaces</option>
          <option value="4" selected>4 spaces</option>
          <option value="tab">Tab</option>
        </select>
      </div>
      <div class="action-button">
        <button id="processButton">Format Code</button>
      </div>
    </div>
    
    <div class="editor-container">
      <div class="editor-box">
        <h3>Original Code</h3>
        <textarea id="originalCode" class="editor" placeholder="Paste your code here..."></textarea>
      </div>
      <div class="editor-box">
        <h3>
          <span id="outputLabel">Formatted Code</span>
          <button id="copyButton" class="copy-button" disabled>Copy</button>
        </h3>
        <textarea id="outputCode" class="editor" readonly></textarea>
      </div>
    </div>
    
    <div class="stats" id="stats"></div>
  </div>

  <script>
    // Code Utility Library
    const CodeUtility = (function() {
      // Helper function to create indentation
      function createIndent(level, indentType) {
        if (indentType === 'tab') {
          return '\t'.repeat(level);
        } else {
          const spaces = parseInt(indentType, 10) || 2;
          return ' '.repeat(spaces * level);
        }
      }
      
      // JavaScript formatting
      function formatJS(code, indentType) {
        if (!code || typeof code !== 'string') return '';
        
        try {
          // For critical syntax repairs
          code = fixSyntaxErrors(code);
          
          // Split code into meaningful chunks while preserving structure
          const tokens = tokenizeJS(code);
          
          // Format with proper indentation
          let result = '';
          let indentLevel = 0;
          let inObjectLiteral = false;
          let inArrayLiteral = false;
          let pendingIndent = false;
          
          for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const nextToken = tokens[i + 1] || { type: 'none', value: '' };
            const prevToken = tokens[i - 1] || { type: 'none', value: '' };
            
            switch (token.type) {
              case 'string':
              case 'regex':
              case 'template':
                // Preserve strings and regexes as-is
                if (pendingIndent) {
                  result += createIndent(indentLevel, indentType);
                  pendingIndent = false;
                }
                result += token.value;
                break;
                
              case 'comment':
                // Format comments
                if (token.value.startsWith('//')) {
                  if (!result.endsWith('\n')) result += '\n';
                  result += createIndent(indentLevel, indentType) + token.value.trim();
                  pendingIndent = true;
                } else {
                  // Multi-line comment
                  if (!result.endsWith('\n')) result += '\n';
                  
                  const commentLines = token.value.split('\n');
                  result += createIndent(indentLevel, indentType) + commentLines[0].trim();
                  
                  for (let j = 1; j < commentLines.length; j++) {
                    result += '\n' + createIndent(indentLevel, indentType) + commentLines[j].trim();
                  }
                  
                  pendingIndent = true;
                }
                break;
                
              case 'punctuation':
                if (token.value === '{') {
                  // Opening brace - check if it's for an object literal or block
                  if (isObjectLiteralStart(prevToken)) {
                    inObjectLiteral = true;
                    
                    if (pendingIndent) {
                      result += createIndent(indentLevel, indentType);
                      pendingIndent = false;
                    }
                    
                    result += '{';
                    indentLevel++;
                    pendingIndent = true;
                  } else {
                    // Block statement
                    if (isBlockStart(prevToken)) {
                      result = result.trimRight() + ' {';
                    } else {
                      if (pendingIndent) {
                        result += createIndent(indentLevel, indentType);
                        pendingIndent = false;
                      }
                      result += '{';
                    }
                    indentLevel++;
                    pendingIndent = true;
                  }
                } 
                else if (token.value === '}') {
                  // Closing brace
                  indentLevel = Math.max(0, indentLevel - 1);
                  
                  if (inObjectLiteral) {
                    if (!result.endsWith('\n')) {
                      result += '\n';
                    }
                    result += createIndent(indentLevel, indentType) + '}';
                    inObjectLiteral = false;
                  } else {
                    if (!result.endsWith('\n')) {
                      result += '\n';
                    }
                    result += createIndent(indentLevel, indentType) + '}';
                  }
                  
                  // Check if this is followed by else, catch, finally
                  if (nextToken.type === 'keyword' && 
                      (nextToken.value === 'else' || 
                       nextToken.value === 'catch' || 
                       nextToken.value === 'finally')) {
                    result += ' ';
                    pendingIndent = false;
                  } else {
                    pendingIndent = true;
                  }
                }
                else if (token.value === '[') {
                  // Opening array bracket
                  if (pendingIndent) {
                    result += createIndent(indentLevel, indentType);
                    pendingIndent = false;
                  }
                  result += '[';
                  
                  // Check if this is an array with multiple items
                  if (hasMultipleItems(tokens, i)) {
                    inArrayLiteral = true;
                    indentLevel++;
                    pendingIndent = true;
                  }
                }
                else if (token.value === ']') {
                  // Closing array bracket
                  if (inArrayLiteral) {
                    inArrayLiteral = false;
                    indentLevel = Math.max(0, indentLevel - 1);
                    
                    if (!result.endsWith('\n')) {
                      result += '\n';
                    }
                    result += createIndent(indentLevel, indentType);
                  }
                  result += ']';
                }
                else if (token.value === '(') {
                  // Opening parenthesis - no space before
                  if (pendingIndent) {
                    result += createIndent(indentLevel, indentType);
                    pendingIndent = false;
                  }
                  
                  // Remove any space before paren for function calls
                  if (isFunctionCall(prevToken)) {
                    result = result.replace(/\s+$/, '') + '(';
                  } else {
                    result += '(';
                  }
                }
                else if (token.value === ')') {
                  // Closing parenthesis
                  result += ')';
                }
                else if (token.value === ',') {
                  // Comma - format based on context
                  result += ',';
                  
                  if (inObjectLiteral || inArrayLiteral) {
                    pendingIndent = true;
                  } else if (isMultiVarDeclaration(tokens, i)) {
                    pendingIndent = true;
                  } else {
                    result += ' ';
                  }
                }
                else if (token.value === ';') {
                  // Semicolon - usually indicates end of statement
                  result += ';';
                  
                  // Don't add newline in for loop control parts
                  if (isInForLoopControl(tokens, i)) {
                    result += ' ';
                  } else {
                    pendingIndent = true;
                  }
                }
                else if (token.value === ':') {
                  // Colon - used in object literals, ternary expressions, etc.
                  if (inObjectLiteral) {
                    result += ': ';
                  } else {
                    result += ': ';
                  }
                }
                else {
                  // Other punctuation - preserve as is
                  if (pendingIndent) {
                    result += createIndent(indentLevel, indentType);
                    pendingIndent = false;
                  }
                  result += token.value;
                }
                break;
                
              case 'operator':
                // Format operators with consistent spacing
                if (pendingIndent) {
                  result += createIndent(indentLevel, indentType);
                  pendingIndent = false;
                }
                
                // Special handling for different operator types
                if (token.value === '.' || token.value === '?.') {
                  // No spaces around property access operators
                  result = result.trimRight() + token.value;
                } 
                else if (token.value === '++' || token.value === '--') {
                  // No spaces for increment/decrement
                  result = result.trimRight() + token.value;
                }
                else if (token.value === '=>') {
                  // Arrow functions
                  result += ' => ';
                }
                else {
                  // Standard spacing for most operators
                  if (result.endsWith(' ')) {
                    result += token.value + ' ';
                  } else {
                    result += ' ' + token.value + ' ';
                  }
                }
                break;
                
              case 'keyword':
                // Keywords like if, for, function, etc.
                if (pendingIndent) {
                  result += createIndent(indentLevel, indentType);
                  pendingIndent = false;
                }
                
                // Special formatting for some keywords
                if (token.value === 'else' || token.value === 'catch' || token.value === 'finally') {
                  if (!result.endsWith(' ')) {
                    result += ' ' + token.value;
                  } else {
                    result += token.value;
                  }
                  
                  // Handle else if
                  if (token.value === 'else' && nextToken.type === 'keyword' && nextToken.value === 'if') {
                    result += ' ';
                    i++; // Skip the 'if' token since we're handling it now
                    result += 'if';
                  }
                } 
                else if (token.value === 'function') {
                  result += 'function';
                  
                  // If followed by a name, add space after function
                  if (nextToken.type === 'identifier') {
                    result += ' ';
                  }
                }
                else {
                  result += token.value;
                }
                break;
                
              case 'identifier':
                // Variable and function names
                if (pendingIndent) {
                  result += createIndent(indentLevel, indentType);
                  pendingIndent = false;
                }
                
                // Remove space before opening parenthesis for function calls
                if (nextToken.type === 'punctuation' && nextToken.value === '(') {
                  result += token.value;
                } else {
                  result += token.value;
                  
                  // Add space after identifier if not followed by specific punctuation
                  if (nextToken.type !== 'punctuation' || 
                      !['(', '[', '.', ',', ';', ':', ')', '}', ']'].includes(nextToken.value)) {
                    result += ' ';
                  }
                }
                break;
                
              case 'number':
              case 'boolean':
              case 'null':
              case 'undefined':
                // Literals
                if (pendingIndent) {
                  result += createIndent(indentLevel, indentType);
                  pendingIndent = false;
                }
                result += token.value;
                break;
                
              case 'whitespace':
                // Handle whitespace - normalize to single spaces
                if (token.value.includes('\n')) {
                  if (!pendingIndent) {
                    pendingIndent = true;
                  }
                } else if (!result.endsWith(' ') && !pendingIndent) {
                  result += ' ';
                }
                break;
                
              default:
                // Default handling for any other token type
                if (pendingIndent) {
                  result += createIndent(indentLevel, indentType);
                  pendingIndent = false;
                }
                result += token.value;
                break;
            }
            
            // Add newlines after statements
            if (pendingIndent && !result.endsWith('\n')) {
              result += '\n';
            }
          }
          
          // Final cleanup
          result = result.replace(/\n{3,}/g, '\n\n'); // Limit consecutive blank lines
          result = result.trim();
          if (!result.endsWith('\n')) result += '\n';
          
          return result;
        } catch (error) {
          console.error('Error in JS formatting:', error);
          return code; // Return original code on error
        }
      }
      
      // Tokenize JavaScript code
      function tokenizeJS(code) {
        const tokens = [];
        let i = 0;
        
        // Pre-process to fix obvious syntax errors
        code = code.replace(/(\s*==\s*=\s*)/g, ' === ');
        code = code.replace(/(\s*&\s*&\s*)/g, ' && ');
        code = code.replace(/(\s*\|\s*\|\s*)/g, ' || ');
        
        while (i < code.length) {
          let char = code[i];
          
          // Skip whitespace
          if (/\s/.test(char)) {
            let whitespace = '';
            while (i < code.length && /\s/.test(code[i])) {
              whitespace += code[i];
              i++;
            }
            tokens.push({ type: 'whitespace', value: whitespace });
            continue;
          }
          
          // Handle strings
          if (char === '"' || char === "'" || char === '`') {
            let string = char;
            const quote = char;
            i++;
            
            while (i < code.length) {
              char = code[i];
              string += char;
              i++;
              
              if (char === quote && code[i - 2] !== '\\') {
                break;
              }
            }
            
            tokens.push({ type: 'string', value: string });
            continue;
          }
          
          // Handle comments
          if (char === '/' && code[i + 1] === '/') {
            let comment = '//';
            i += 2;
            
            while (i < code.length && code[i] !== '\n') {
              comment += code[i];
              i++;
            }
            
            tokens.push({ type: 'comment', value: comment });
            continue;
          }
          
          if (char === '/' && code[i + 1] === '*') {
            let comment = '/*';
            i += 2;
            
            while (i < code.length && !(code[i] === '*' && code[i + 1] === '/')) {
              comment += code[i];
              i++;
            }
            
            if (i < code.length) {
              comment += '*/';
              i += 2;
            }
            
            tokens.push({ type: 'comment', value: comment });
            continue;
          }
          
          // Handle regex literals - simplified detection
          if (char === '/' && isRegexStart(tokens)) {
            let regex = '/';
            i++;
            
            // Match regex body
            while (i < code.length && code[i] !== '/' && code[i] !== '\n') {
              // Handle escaped forward slashes
              if (code[i] === '\\' && code[i + 1] === '/') {
                regex += '\\';
                i++;
              }
              regex += code[i];
              i++;
            }
            
            // Closing slash
            if (i < code.length && code[i] === '/') {
              regex += '/';
              i++;
              
              // Match regex flags
              while (i < code.length && /[gimuy]/.test(code[i])) {
                regex += code[i];
                i++;
              }
              
              tokens.push({ type: 'regex', value: regex });
              continue;
            }
          }
          
          // Handle numbers
          if (/\d/.test(char) || (char === '.' && /\d/.test(code[i + 1]))) {
            let number = '';
            
            // Handle decimal, hexadecimal, octal, binary, and scientific notation
            if (char === '0' && (code[i + 1] === 'x' || code[i + 1] === 'X')) {
              // Hexadecimal
              number = '0' + code[i + 1];
              i += 2;
              while (i < code.length && /[0-9a-fA-F]/.test(code[i])) {
                number += code[i];
                i++;
              }
            } else {
              // Decimal, octal, binary or scientific
              while (i < code.length && (/[\d.eE+-]/.test(code[i]) || 
                    (code[i].toLowerCase() === 'n' && /\d/.test(code[i-1])))) {
                number += code[i];
                i++;
                
                // Handle scientific notation
                if ((code[i - 1] === 'e' || code[i - 1] === 'E') && 
                    (code[i] === '+' || code[i] === '-')) {
                  number += code[i];
                  i++;
                }
              }
            }
            
            tokens.push({ type: 'number', value: number });
            continue;
          }
          
          // Handle identifiers and keywords
          if (/[a-zA-Z_$]/.test(char)) {
            let identifier = '';
            
            while (i < code.length && /[a-zA-Z0-9_$]/.test(code[i])) {
              identifier += code[i];
              i++;
            }
            
            // Check if it's a keyword
            const keywords = [
              'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 
              'default', 'delete', 'do', 'else', 'export', 'extends', 'finally', 
              'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'return', 
              'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 
              'while', 'with', 'yield', 'let', 'static', 'enum', 'await', 'implements', 
              'package', 'protected', 'interface', 'private', 'public'
            ];
            
            if (keywords.includes(identifier)) {
              tokens.push({ type: 'keyword', value: identifier });
            } else if (identifier === 'true' || identifier === 'false') {
              tokens.push({ type: 'boolean', value: identifier });
            } else if (identifier === 'null') {
              tokens.push({ type: 'null', value: 'null' });
            } else if (identifier === 'undefined') {
              tokens.push({ type: 'undefined', value: 'undefined' });
            } else {
              tokens.push({ type: 'identifier', value: identifier });
            }
            
            continue;
          }
          
          // Handle operators
          const operators = [
            '++', '--', '**', '===', '!==', '==', '!=', '>=', '<=', '>>', '<<', '>>>', '&&', '||',
            '+=', '-=', '*=', '/=', '%=', '&=', '|=', '^=', '<<=', '>>=', '>>>=', '=>', '?.',
            '=', '+', '-', '*', '/', '%', '&', '|', '^', '~', '!', '>', '<', '?', ':'
          ];
          
          let isOperator = false;
          for (const op of operators) {
            if (code.substring(i, i + op.length) === op) {
              tokens.push({ type: 'operator', value: op });
              i += op.length;
              isOperator = true;
              break;
            }
          }
          if (isOperator) continue;
          
          // Handle punctuation
          const punctuation = ['{', '}', '(', ')', '[', ']', ';', ',', '.'];
          if (punctuation.includes(char)) {
            tokens.push({ type: 'punctuation', value: char });
            i++;
            continue;
          }
          
          // Unknown character, just add it and move on
          tokens.push({ type: 'unknown', value: char });
          i++;
        }
        
        return tokens;
      }
      
      // Helper function to fix common syntax errors
      function fixSyntaxErrors(code) {
        // Fix missing object braces
        code = code.replace(/([a-zA-Z0-9_$]+)\s*=\s*([a-zA-Z0-9_$]+):\s*([^,;{}\n]+)(?!\s*[,}])/g, '$1 = { $2: $3 }');
        
        // Fix incorrect operator spacing
        code = code.replace(/([=<>!&|+\-*\/%^])\s+([=<>!&|+\-*\/%^])/g, '$1$2');
        
        return code;
      }
      
      // Helper function to check if token can start a regex
      function isRegexStart(tokens) {
        if (tokens.length === 0) return true;
        
        // Look at the last non-whitespace token
        let i = tokens.length - 1;
        while (i >= 0 && tokens[i].type === 'whitespace') {
          i--;
        }
        
        if (i < 0) return true;
        
        const lastToken = tokens[i];
        
        // Regex can follow these tokens
        if (lastToken.type === 'punctuation' && ['(', '[', '{', ',', ';', ':'].includes(lastToken.value)) {
          return true;
        }
        
        // Regex can follow these operators
        if (lastToken.type === 'operator' && ['=', '&&', '||', '!', '+', '-', '*', '/', '%', '|', '&', '^', '~', '<', '>', '?'].includes(lastToken.value)) {
          return true;
        }
        
        // Regex can follow certain keywords
        if (lastToken.type === 'keyword' && ['return', 'case', 'delete', 'throw', 'void', 'typeof', 'yield'].includes(lastToken.value)) {
          return true;
        }
        
        return false;
      }
      
      // Helper function to check if token is start of object literal
      function isObjectLiteralStart(token) {
        if (!token) return false;
        
        // Typical patterns before object literals
        if (token.type === 'operator' && ['=', ':', '(', ',', '?', '||', '&&', 'return'].includes(token.value)) {
          return true;
        }
        
        return false;
      }
      
      // Helper function to check if token is start of a block
      function isBlockStart(token) {
        if (!token) return false;
        
        // Blocks typically follow these patterns
        if (token.type === 'keyword' && ['if', 'for', 'while', 'switch', 'catch', 'function', 'else'].includes(token.value)) {
          return true;
        }
        
        if (token.type === 'punctuation' && token.value === ')') {
          return true;
        }
        
        return false;
      }
      
      // Helper function to check if array has multiple items
      function hasMultipleItems(tokens, startIndex) {
        let depth = 1;
        let hasItems = false;
        let commaCount = 0;
        
        for (let i = startIndex + 1; i < tokens.length; i++) {
          const token = tokens[i];
          
          if (token.type === 'punctuation') {
            if (token.value === '[') depth++;
            else if (token.value === ']') {
              depth--;
              if (depth === 0) break;
            }
            else if (token.value === ',' && depth === 1) {
              commaCount++;
              if (commaCount > 0) return true;
            }
          }
        }
        
        return false;
      }
      
      // Helper function to check if token is a function call
      function isFunctionCall(token) {
        if (!token) return false;
        return token.type === 'identifier';
      }
      
      // Helper function to check if comma is part of multi-variable declaration
      function isMultiVarDeclaration(tokens, index) {
        // Look back for variable declaration keywords
        for (let i = index - 1; i >= 0; i--) {
          if (tokens[i].type === 'punctuation' && tokens[i].value === ';') {
            return false;
          }
          
          if (tokens[i].type === 'keyword' && ['var', 'let', 'const'].includes(tokens[i].value)) {
            return true;
          }
        }
        
        return false;
      }
      
      // Helper function to check if in for loop control
      function isInForLoopControl(tokens, index) {
        let parenDepth = 0;
        let foundFor = false;
        
        // Look back for for keyword and opening paren
        for (let i = index; i >= 0; i--) {
          const token = tokens[i];
          
          if (token.type === 'punctuation') {
            if (token.value === ')') parenDepth++;
            else if (token.value === '(') {
              parenDepth--;
              if (parenDepth < 0 && foundFor) return true;
            }
          }
          
          if (token.type === 'keyword' && token.value === 'for') {
            foundFor = true;
          }
        }
        
        return false;
      }
      
      // CSS formatting
      function formatCSS(code, indentType) {
        if (!code || typeof code !== 'string') return '';
        
        try {
          // Tokenize CSS for better formatting
          const tokens = [];
          let current = '';
          let inComment = false;
          let inString = false;
          let stringChar = '';
          
          function pushToken(type) {
            if (current) {
              tokens.push({ type, value: current });
              current = '';
            }
          }
          
          // Initial tokenization
          for (let i = 0; i < code.length; i++) {
            const char = code[i];
            const next = code[i + 1] || '';
            
            // Handle comments
            if (char === '/' && next === '*' && !inString && !inComment) {
              pushToken('code');
              current += '/*';
              inComment = true;
              i++; // Skip next char
              continue;
            }
            
            if (inComment && char === '*' && next === '/') {
              current += '*/';
              pushToken('comment');
              inComment = false;
              i++; // Skip next char
              continue;
            }
            
            // Handle strings
            if ((char === '"' || char === "'") && !inComment) {
              if (inString && stringChar === char && code[i - 1] !== '\\') {
                current += char;
                pushToken('string');
                inString = false;
              } else if (!inString) {
                pushToken('code');
                current += char;
                inString = true;
                stringChar = char;
              } else {
                current += char;
              }
              continue;
            }
            
            // Handle special characters when not in comments or strings
            if (!inComment && !inString) {
              if (char === '{' || char === '}' || char === ';') {
                pushToken('code');
                pushToken(char === '{' ? 'openBrace' : char === '}' ? 'closeBrace' : 'semicolon');
                continue;
              }
            }
            
            current += char;
          }
          
          // Push any remaining token
          if (inComment) pushToken('comment');
          else if (inString) pushToken('string');
          else pushToken('code');
          
          // Format with proper indentation
          let result = '';
          let indentLevel = 0;
          let lastType = null;
          
          for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const next = tokens[i + 1] || { type: 'none' };
            const prev = tokens[i - 1] || { type: 'none' };
            
            if (token.type === 'string') {
              // Preserve strings as-is
              result += token.value;
            } else if (token.type === 'comment') {
              // Format comments
              const lines = token.value.split('\n');
              if (lines.length > 1) {
                if (!result.endsWith('\n')) result += '\n';
                result += createIndent(indentLevel, indentType) + lines[0].trim() + '\n';
                
                for (let j = 1; j < lines.length - 1; j++) {
                  result += createIndent(indentLevel, indentType) + ' * ' + lines[j].trim() + '\n';
                }
                
                if (lines.length > 1) {
                  result += createIndent(indentLevel, indentType) + ' ' + lines[lines.length - 1].trim() + '\n';
                }
              } else {
                if (prev.type === 'code' && !result.endsWith('\n')) {
                  result += ' ';
                }
                result += token.value;
                if (next.type === 'code' && !token.value.endsWith('\n')) {
                  result += ' ';
                }
              }
            } else if (token.type === 'openBrace') {
              // Opening brace for CSS rule sets
              result = result.trimRight() + ' {\n';
              indentLevel++;
              
              // Next line should be indented
              result += createIndent(indentLevel, indentType);
            } else if (token.type === 'closeBrace') {
              // Closing brace for CSS rule sets
              indentLevel = Math.max(0, indentLevel - 1);
              
              // Ensure it's properly aligned with opening brace
              if (!result.endsWith('\n')) {
                result += '\n';
              }
              result = result.trimRight() + '\n' + createIndent(indentLevel, indentType) + '}';
              
              // Add a newline after the closing brace for better readability
              result += '\n\n';
              
              // If there's more content, add proper indentation
              if (next.type !== 'none' && next.type !== 'closeBrace') {
                result += createIndent(indentLevel, indentType);
              }
            } else if (token.type === 'semicolon') {
              // Semicolons in CSS property declarations
              result += ';';
              
              // End of property line, add a newline and indentation for the next line
              if (next.type !== 'closeBrace') {
                result += '\n' + createIndent(indentLevel, indentType);
              }
            } else {
              // Regular CSS code
              let cssText = token.value.trim();
              
              // Clean up spaces, but keep one space after colon in properties
              cssText = cssText.replace(/:\s+/g, ': ');
              
              // Format comma-separated selectors
              cssText = cssText.replace(/,\s*/g, ', ');
              
              // Format media queries
              cssText = cssText.replace(/@media\s*\(/g, '@media (');
              
              // Add indentation if this is a new line
              if (result.endsWith('\n')) {
                result += createIndent(indentLevel, indentType);
              }
              
              result += cssText;
              
              // For selectors that are followed by an opening brace, make sure they're on their own line
              if (next.type === 'openBrace' && cssText.includes(',')) {
                // Try to prettify multi-selector rules by putting each on its own line
                const selectors = cssText.split(',').map(s => s.trim());
                if (selectors.length > 1) {
                  result = result.substring(0, result.length - cssText.length);
                  result += selectors.join(',\n' + createIndent(indentLevel, indentType));
                }
              }
            }
            
            lastType = token.type;
          }
          
          // Final cleanup
          result = result.replace(/\n{3,}/g, '\n\n'); // Limit consecutive newlines
          result = result.trim() + '\n';
          
          return result;
        } catch (error) {
          console.error('Error in CSS formatting:', error);
          return code; // Return original code on error
        }
      }
      
      // HTML formatting
      function formatHTML(code, indentType) {
        if (!code || typeof code !== 'string') return '';
        
        try {
          // First extract script and style tags to format them separately
          const extractedTags = [];
          
          // Function to extract content from tags that should be processed separately
          function extractTagContent(html, tagName) {
            const pattern = new RegExp(`<${tagName}([^>]*)>([\\s\\S]*?)<\\/${tagName}>`, 'gi');
            return html.replace(pattern, (match, attributes, content) => {
              const id = `###${tagName}-${extractedTags.length}###`;
              extractedTags.push({
                id,
                tagName,
                attributes,
                content
              });
              return `<${tagName}${attributes}>${id}</${tagName}>`;
            });
          }
          
          // Extract script, style, and pre tags
          let processedHtml = code;
          processedHtml = extractTagContent(processedHtml, 'script');
          processedHtml = extractTagContent(processedHtml, 'style');
          processedHtml = extractTagContent(processedHtml, 'pre');
          processedHtml = extractTagContent(processedHtml, 'textarea');
          
          // Now parse the HTML structure
          const tokens = [];
          let currentToken = '';
          let tokenType = 'text';
          let inComment = false;
          
          function pushToken(type) {
            if (currentToken) {
              tokens.push({ type, content: currentToken });
              currentToken = '';
            }
          }
          
          // Split into tokens (tags, text, comments)
          for (let i = 0; i < processedHtml.length; i++) {
            const char = processedHtml[i];
            const nextChar = processedHtml[i + 1] || '';
            
            // Handle comments
            if (char === '<' && nextChar === '!' && processedHtml.substr(i, 4) === '<!--') {
              pushToken(tokenType);
              tokenType = 'comment';
              currentToken = '<!--';
              i += 3; // Skip "!--"
              continue;
            }
            
            if (inComment && char === '-' && nextChar === '-' && processedHtml.substr(i, 3) === '-->') {
              currentToken += '-->';
              pushToken('comment');
              inComment = false;
              tokenType = 'text';
              i += 2; // Skip "-->"
              continue;
            }
            
            if (tokenType === 'comment') {
              currentToken += char;
              inComment = true;
              continue;
            }
            
            // Handle tags
            if (char === '<' && nextChar !== '!' && !inComment) {
              pushToken(tokenType);
              tokenType = 'tag';
              currentToken = '<';
              continue;
            }
            
            if (tokenType === 'tag' && char === '>') {
              currentToken += '>';
              pushToken('tag');
              tokenType = 'text';
              continue;
            }
            
            // Add character to current token
            currentToken += char;
          }
          
          // Push any remaining token
          pushToken(tokenType);
          
          // Format the tokens with proper indentation
          let result = '';
          let indentLevel = 0;
          let lastTokenWasClosingTag = false;
          
          // Helper to check if tag is self-closing or void
          function isSelfClosingTag(tag) {
            if (!tag.startsWith('<')) return false;
            if (tag.includes('/>')) return true;
            
            // Check for void elements
            const voidElements = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr'];
            for (const element of voidElements) {
              if (new RegExp(`<${element}(\\s|>)`, 'i').test(tag)) return true;
            }
            
            return false;
          }
          
          // Helper to check if tag is a closing tag
          function isClosingTag(tag) {
            return tag.startsWith('</');
          }
          
          // Helper to get tag name
          function getTagName(tag) {
            if (tag.startsWith('</')) {
              return tag.substring(2, tag.indexOf('>')).trim().split(/\s+/)[0].toLowerCase();
            } else {
              return tag.substring(1, tag.indexOf('>')).trim().split(/\s+/)[0].toLowerCase();
            }
          }
          
          // Helper to check if text is just whitespace
          function isWhitespace(text) {
            return /^\s*$/.test(text);
          }
          
          // Format tokens
          for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const prevToken = tokens[i - 1] || { type: 'none' };
            const nextToken = tokens[i + 1] || { type: 'none' };
            
            if (token.type === 'tag') {
              const tagContent = token.content;
              
              // Format attribute spacing
              let formattedTag = tagContent
                .replace(/\s+/g, ' ')            // Replace multiple spaces with single space
                .replace(/\s*=\s*/g, '=')        // Remove spaces around equals
                .replace(/=([^"][^\s>]*)/g, '="$1"'); // Add quotes to attributes
              
              // If it's a long tag with multiple attributes, format for readability
              if (formattedTag.length > 80 && formattedTag.includes(' ')) {
                const tagName = getTagName(formattedTag);
                const firstSpaceIndex = formattedTag.indexOf(' ');
                
                // Add newline and indentation for each attribute
                let attributePart = formattedTag.substring(firstSpaceIndex).trim();
                attributePart = attributePart.replace(/\s+([a-zA-Z\-]+)=/g, '\n' + createIndent(indentLevel + 1, indentType) + '$1=');
                
                formattedTag = formattedTag.substring(0, firstSpaceIndex) + 
                               attributePart + 
                               '\n' + createIndent(indentLevel, indentType);
              }
              
              if (isClosingTag(tagContent)) {
                // If it's a closing tag, reduce indent level before rendering
                indentLevel = Math.max(0, indentLevel - 1);
                
                if (prevToken.type === 'text' && !isWhitespace(prevToken.content)) {
                  // If previous token is non-whitespace text, keep on same line
                  result += formattedTag;
                } else {
                  // Otherwise, put on new line with proper indentation
                  if (!result.endsWith('\n')) result += '\n';
                  result += createIndent(indentLevel, indentType) + formattedTag;
                }
                
                lastTokenWasClosingTag = true;
              } else if (isSelfClosingTag(tagContent)) {
                // Self-closing tags don't change indentation
                if (!result.endsWith('\n')) result += '\n';
                result += createIndent(indentLevel, indentType) + formattedTag;
                lastTokenWasClosingTag = false;
              } else {
                // Opening tag
                if (!result.endsWith('\n')) result += '\n';
                result += createIndent(indentLevel, indentType) + formattedTag;
                indentLevel++;
                lastTokenWasClosingTag = false;
              }
            } else if (token.type === 'comment') {
              // Format comments
              if (!result.endsWith('\n')) result += '\n';
              
              // Multi-line comment formatting
              if (token.content.includes('\n')) {
                const lines = token.content.split('\n');
                result += createIndent(indentLevel, indentType) + lines[0].trim() + '\n';
                
                for (let j = 1; j < lines.length - 1; j++) {
                  result += createIndent(indentLevel, indentType) + lines[j].trim() + '\n';
                }
                
                result += createIndent(indentLevel, indentType) + lines[lines.length - 1].trim();
              } else {
                result += createIndent(indentLevel, indentType) + token.content.trim();
              }
              
              lastTokenWasClosingTag = false;
            } else if (token.type === 'text') {
              if (isWhitespace(token.content)) {
                // Skip pure whitespace between tags
                continue;
              }
              
              // Handle text content
              const trimmedContent = token.content.trim().replace(/\s+/g, ' ');
              
              if (lastTokenWasClosingTag || result.endsWith('\n')) {
                result += createIndent(indentLevel, indentType);
              }
              
              result += trimmedContent;
              lastTokenWasClosingTag = false;
            }
          }
          
          // Now restore the extracted content
          for (const tag of extractedTags) {
            let formattedContent;
            
            if (tag.tagName.toLowerCase() === 'script') {
              formattedContent = formatJS(tag.content, indentType);
            } else if (tag.tagName.toLowerCase() === 'style') {
              formattedContent = formatCSS(tag.content, indentType);
            } else {
              // For pre and textarea, preserve the content exactly as is
              formattedContent = tag.content;
            }
            
            // Replace the placeholder with formatted content
            const placeholder = new RegExp(`${tag.id}`, 'g');
            
            if (tag.tagName.toLowerCase() === 'script' || tag.tagName.toLowerCase() === 'style') {
              const contentIndent = createIndent(indentLevel, indentType);
              result = result.replace(placeholder, '\n' + formattedContent.split('\n').map(line => 
                line.trim() ? contentIndent + line : line
              ).join('\n') + '\n' + contentIndent);
            } else {
              result = result.replace(placeholder, formattedContent);
            }
          }
          
          // Final cleanup
          result = result.replace(/\n{3,}/g, '\n\n');  // Limit consecutive newlines
          result = result.trim();
          
          return result;
        } catch (error) {
          console.error('Error in HTML formatting:', error);
          return code; // Return original code on error
        }
      }
      
      // JavaScript minification
      function minifyJS(code) {
        if (!code || typeof code !== 'string') return '';
        
        try {
          // Remove comments (both single-line and multi-line)
          let minified = code.replace(/\/\/.*$/gm, '')
                            .replace(/\/\*[\s\S]*?\*\//g, '')
                            .replace(/^\s*\n/gm, '');
          
          // Remove unnecessary whitespace
          minified = minified.replace(/\s+/g, ' ');
          
          // Remove whitespace around operators and brackets
          minified = minified.replace(/\s*([{}:;,=+\-*/<>()&|!])\s*/g, '$1');
          
          // Fix spacing issues caused by previous replacements
          minified = minified.replace(/}else/g, '}else');
          minified = minified.replace(/else{/g, 'else{');
          minified = minified.replace(/if\(/g, 'if(');
          minified = minified.replace(/for\(/g, 'for(');
          minified = minified.replace(/while\(/g, 'while(');
          minified = minified.replace(/function\(/g, 'function(');
          
          // Restore necessary spaces
          minified = minified.replace(/([+\-*/<>])\(/g, '$1(');
          minified = minified.replace(/return\(/g, 'return(');
          
          // Handle special cases
          minified = minified.replace(/\s*;\s*/g, ';');
          
          // Final cleanup
          minified = minified.trim();
          
          return minified;
        } catch (error) {
          console.error('Error in JS minification:', error);
          return code; // Return original code on error
        }
      }
      
      // CSS minification
      function minifyCSS(code) {
        if (!code || typeof code !== 'string') return '';
        
        try {
          // Remove comments
          let minified = code.replace(/\/\*[\s\S]*?\*\//g, '');
          
          // Remove whitespace around brackets, colons, semicolons
          minified = minified.replace(/\s*([{}:;,])\s*/g, '$1');
          
          // Replace multiple whitespaces with single space
          minified = minified.replace(/\s+/g, ' ');
          
          // Remove spaces after and before brackets
          minified = minified.replace(/\s*{\s*/g, '{');
          minified = minified.replace(/\s*}\s*/g, '}');
          
          // Remove semicolons before closing bracket
          minified = minified.replace(/;\}/g, '}');
          
          // Remove leading and trailing whitespace
          minified = minified.trim();
          
          return minified;
        } catch (error) {
          console.error('Error in CSS minification:', error);
          return code; // Return original code on error
        }
      }
      
      // HTML minification
      function minifyHTML(code) {
        if (!code || typeof code !== 'string') return '';
        
        try {
          // Remove comments (except conditional comments for IE)
          let minified = code.replace(/<!--(?!\[if\s)[\s\S]*?-->/g, '');
          
          // Remove whitespace between tags
          minified = minified.replace(/>\s+</g, '><');
          
          // Remove leading and trailing whitespace in elements
          minified = minified.replace(/\s+>/g, '>');
          minified = minified.replace(/<\s+/g, '<');
          
          // Remove unnecessary whitespace
          minified = minified.replace(/\s{2,}/g, ' ');
          
          // Remove whitespace around attributes
          minified = minified.replace(/\s*=\s*/g, '=');
          
          // Preserve script and style tags content
          const preserveTags = (html, tagName) => {
            const regex = new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)<\\/${tagName}>`, 'gi');
            return html.replace(regex, (match, content) => {
              // Replace the content with a placeholder
              const placeholder = `###${tagName}-${Math.random().toString(36).substring(2, 15)}###`;
              window[placeholder] = content;
              return `<${tagName}>${placeholder}</${tagName}>`;
            });
          };
          
          // Restore script and style tags content
          const restoreTags = (html, tagName) => {
            const regex = new RegExp(`<${tagName}>###${tagName}-([a-z0-9]+)###<\\/${tagName}>`, 'gi');
            return html.replace(regex, (match, id) => {
              const placeholder = `###${tagName}-${id}###`;
              const content = window[placeholder];
              delete window[placeholder];
              return `<${tagName}>${content}</${tagName}>`;
            });
          };
          
          // Preserve and restore script and style content
          minified = preserveTags(minified, 'script');
          minified = preserveTags(minified, 'style');
          minified = restoreTags(minified, 'script');
          minified = restoreTags(minified, 'style');
          
          // Final cleanup
          minified = minified.trim();
          
          return minified;
        } catch (error) {
          console.error('Error in HTML minification:', error);
          return code; // Return original code on error
        }
      }
      
      // Calculate stats for comparison
      function calculateStats(original, processed) {
        if (!original || !processed) {
          return {
            originalSize: 0,
            processedSize: 0,
            difference: 0,
            percentage: 0
          };
        }
        
        const originalSize = new Blob([original]).size;
        const processedSize = new Blob([processed]).size;
        const difference = originalSize - processedSize;
        const percentage = originalSize > 0 ? ((difference / originalSize) * 100) : 0;
        
        return {
          originalSize,
          processedSize,
          difference,
          percentage
        };
      }
      
      // Public API
      return {
        format: function(code, language, indentType) {
          switch (language.toLowerCase()) {
            case 'javascript':
            case 'js':
              return formatJS(code, indentType);
            case 'css':
              return formatCSS(code, indentType);
            case 'html':
              return formatHTML(code, indentType);
            default:
              return code; // Return original for unknown types
          }
        },
        
        minify: function(code, language) {
          switch (language.toLowerCase()) {
            case 'javascript':
            case 'js':
              return minifyJS(code);
            case 'css':
              return minifyCSS(code);
            case 'html':
              return minifyHTML(code);
            default:
              return code.replace(/\s+/g, ' ').trim(); // Basic minification
          }
        },
        
        calculateStats: calculateStats
      };
    })();

    // UI Controller
    const UIController = (function() {
      // DOM elements
      const elements = {
        dropZone: document.getElementById('dropZone'),
        fileInput: document.getElementById('fileInput'),
        selectFileButton: document.getElementById('selectFileButton'),
        originalCode: document.getElementById('originalCode'),
        outputCode: document.getElementById('outputCode'),
        outputLabel: document.getElementById('outputLabel'),
        languageSelect: document.getElementById('languageSelect'),
        indentSelect: document.getElementById('indentSelect'),
        indentContainer: document.getElementById('indentContainer'),
        processButton: document.getElementById('processButton'),
        copyButton: document.getElementById('copyButton'),
        formatBtn: document.getElementById('formatBtn'),
        minifyBtn: document.getElementById('minifyBtn'),
        stats: document.getElementById('stats')
      };
      
      // Current mode (format or minify)
      let currentMode = 'format';
      
      // Setup event listeners
      function setupEventListeners() {
        // Mode toggle buttons
        elements.formatBtn.addEventListener('click', () => {
          setMode('format');
        });
        
        elements.minifyBtn.addEventListener('click', () => {
          setMode('minify');
        });
        
        // File drag and drop
        elements.dropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          elements.dropZone.classList.add('active');
        });
        
        elements.dropZone.addEventListener('dragleave', (e) => {
          e.preventDefault();
          e.stopPropagation();
          elements.dropZone.classList.remove('active');
        });
        
        elements.dropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          elements.dropZone.classList.remove('active');
          
          const files = e.dataTransfer.files;
          if (files.length > 0) {
            handleFile(files[0]);
          }
        });
        
        // File selection
        elements.selectFileButton.addEventListener('click', () => {
          elements.fileInput.click();
        });
        
        elements.fileInput.addEventListener('change', (e) => {
          if (e.target.files.length > 0) {
            handleFile(e.target.files[0]);
          }
        });
        
        // Process button
        elements.processButton.addEventListener('click', () => {
          processCode();
        });
        
        // Copy button
        elements.copyButton.addEventListener('click', () => {
          copyToClipboard();
        });
        
        // Auto-detect language from file extension
        elements.originalCode.addEventListener('input', () => {
          updateUI();
        });
      }
      
      // Set the current operation mode
      function setMode(mode) {
        currentMode = mode;
        
        // Update UI based on mode
        if (mode === 'format') {
          elements.formatBtn.classList.add('active');
          elements.minifyBtn.classList.remove('active');
          elements.indentContainer.style.display = 'block';
          elements.processButton.textContent = 'Format Code';
          elements.outputLabel.textContent = 'Formatted Code';
        } else {
          elements.formatBtn.classList.remove('active');
          elements.minifyBtn.classList.add('active');
          elements.indentContainer.style.display = 'none';
          elements.processButton.textContent = 'Minify Code';
          elements.outputLabel.textContent = 'Minified Code';
        }
        
        // Clear the output when changing modes but don't automatically process
        elements.outputCode.value = '';
        elements.stats.innerHTML = '';
        elements.copyButton.disabled = true;
      }
      
      // Handle file upload
      function handleFile(file) {
        const reader = new FileReader();
        
        reader.onload = (event) => {
          elements.originalCode.value = event.target.result;
          
          // Auto-detect language from file extension
          const fileName = file.name.toLowerCase();
          if (fileName.endsWith('.js')) {
            elements.languageSelect.value = 'javascript';
          } else if (fileName.endsWith('.css')) {
            elements.languageSelect.value = 'css';
          } else if (fileName.endsWith('.html') || fileName.endsWith('.htm')) {
            elements.languageSelect.value = 'html';
          }
          
          // Just update UI, don't automatically process
          updateUI();
        };
        
        reader.readAsText(file);
      }
      
      // Process code based on current mode
      function processCode() {
        const code = elements.originalCode.value;
        const language = elements.languageSelect.value;
        const indentType = elements.indentSelect.value;
        
        if (!code.trim()) {
          alert('Please enter or upload code first');
          return;
        }
        
        try {
          let processed;
          
          if (currentMode === 'format') {
            processed = CodeUtility.format(code, language, indentType);
          } else {
            processed = CodeUtility.minify(code, language);
          }
          
          elements.outputCode.value = processed;
          
          // Update stats
          updateStats(code, processed);
          
          // Enable copy button
          elements.copyButton.disabled = false;
        } catch (error) {
          console.error('Processing error:', error);
          alert('Error processing code. Please check the console for details.');
        }
      }
      
      // Update stats display
      function updateStats(original, processed) {
        const stats = CodeUtility.calculateStats(original, processed);
        
        const originalKB = (stats.originalSize / 1024).toFixed(2);
        const processedKB = (stats.processedSize / 1024).toFixed(2);
        
        let statsHTML = `
          <h3>Statistics</h3>
          <p>Original size: ${originalKB} KB (${stats.originalSize.toLocaleString()} bytes)</p>
          <p>${currentMode === 'format' ? 'Formatted' : 'Minified'} size: ${processedKB} KB (${stats.processedSize.toLocaleString()} bytes)</p>
        `;
        
        if (currentMode === 'minify') {
          const reduction = stats.percentage.toFixed(2);
          const ratio = stats.originalSize > 0 ? (stats.originalSize / stats.processedSize).toFixed(2) : 0;
          
          statsHTML += `
            <p>Reduction: ${reduction}%</p>
            <p>Compression ratio: ${ratio}:1</p>
          `;
        } else {
          // For formatting, show line count difference
          const originalLines = original.split('\n').length;
          const formattedLines = processed.split('\n').length;
          const lineDiff = formattedLines - originalLines;
          
          statsHTML += `
            <p>Original lines: ${originalLines}</p>
            <p>Formatted lines: ${formattedLines} (${lineDiff > 0 ? '+' + lineDiff : lineDiff})</p>
          `;
        }
        
        elements.stats.innerHTML = statsHTML;
      }
      
      // Copy to clipboard
      function copyToClipboard() {
        const outputCode = elements.outputCode.value;
        
        if (!outputCode) {
          return;
        }
        
        navigator.clipboard.writeText(outputCode).then(() => {
          const originalText = elements.copyButton.textContent;
          elements.copyButton.textContent = 'Copied!';
          elements.copyButton.classList.add('copy-success');
          
          setTimeout(() => {
            elements.copyButton.textContent = originalText;
            elements.copyButton.classList.remove('copy-success');
          }, 2000);
        }).catch(err => {
          console.error('Could not copy text: ', err);
          alert('Failed to copy to clipboard');
        });
      }
      
      // Update UI based on current state
      function updateUI() {
        if (elements.originalCode.value.trim()) {
          elements.processButton.disabled = false;
        } else {
          elements.processButton.disabled = true;
          elements.copyButton.disabled = true;
        }
      }
      
      // Public API
      return {
        init: function() {
          setupEventListeners();
          updateUI();
          console.log('Code Utility initialized');
        }
      };
    })();

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      UIController.init();
    });
  </script>
</body>
</html>