<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Knowledge Base Editor (Document Import)</title>
  <!-- Font Awesome from CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <!-- Quill.js for rich text editing -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/quill/1.3.7/quill.snow.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/quill/1.3.7/quill.min.js"></script>
  <!-- Mammoth.js for DOCX conversion -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.0/mammoth.browser.min.js"></script>
  <style>
    /* Reset and base styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    body {
      background-color: #f8fafc;
      color: #1e293b;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* Header styles */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background-color: #1e293b;
      color: white;
    }
    
    .header-title {
      font-size: 1.25rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .header-actions {
      display: flex;
      gap: 0.5rem;
    }
    
    /* Button styles */
    button {
      cursor: pointer;
      border: none;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    
    .btn {
      padding: 0.5rem 0.75rem;
      font-weight: 500;
    }
    
    .btn-small {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
    }
    
    .btn-primary {
      background-color: #2563eb;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #3b82f6;
    }
    
    .btn-secondary {
      background-color: #334155;
      color: white;
    }
    
    .btn-secondary:hover {
      background-color: #475569;
    }
    
    .btn-success {
      background-color: #16a34a;
      color: white;
    }
    
    .btn-success:hover {
      background-color: #22c55e;
    }
    
    .btn-danger {
      background-color: #dc2626;
      color: white;
    }
    
    .btn-danger:hover {
      background-color: #ef4444;
    }
    
    .btn-icon {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border-radius: 0.25rem;
      transition: background-color 0.1s ease;
    }
    
    .btn-icon:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }
    
    .btn-icon.edit {
      color: #64748b;
    }
    
    .btn-icon.add {
      color: #64748b;
    }
    
    .btn-icon.delete {
      color: #64748b;
    }
    
    /* Main container */
    main {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    /* Drop zone */
    .drop-zone {
      border: 2px dashed #cbd5e1;
      border-radius: 0.5rem;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .drop-zone:hover {
      border-color: #94a3b8;
    }
    
    .drop-zone.active {
      border-color: #3b82f6;
      background-color: #eff6ff;
    }
    
    .drop-zone-icon {
      color: #94a3b8;
      margin-bottom: 0.5rem;
      font-size: 2rem;
    }
    
    .drop-zone-text {
      color: #64748b;
      margin-bottom: 0.25rem;
    }
    
    .drop-zone-subtext {
      color: #94a3b8;
      font-size: 0.875rem;
    }
    
    /* Filename input */
    .filename-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .filename-label {
      font-weight: 600;
      color: #334155;
    }
    
    /* Cards */
    .card {
      background-color: white;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      padding: 1rem;
    }
    
    /* Form inputs */
    .form-group {
      margin-bottom: 1rem;
      position: relative;
    }
    
    .form-group:last-child {
      margin-bottom: 0;
    }
    
    label {
      display: block;
      font-weight: 600;
      color: #334155;
      margin-bottom: 0.25rem;
    }
    
    input[type="text"],
    textarea,
    select {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid #cbd5e1;
      border-radius: 0.25rem;
      font-size: 0.875rem;
    }
    
    input[type="text"]:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }
    
    textarea {
      resize: vertical;
      min-height: 5rem;
    }

    /* Tree view */
    .tree-view {
      font-size: 0.875rem;
    }
    
    .tree-node {
      margin: 0.25rem 0;
    }
    
    /* Enhanced node header styles for drag and drop */
    .node-header {
      display: flex;
      align-items: center;
      padding: 0.375rem 0.25rem;
      cursor: pointer;
      border-bottom: 1px solid #d5e3ea;
      position: relative; /* Required for drop indicators */
      transition: background-color 0.15s ease, border-color 0.15s ease;
    }
    
    .node-header:hover {
      background-color: #f1f5f9;
    }
    
    .node-header.draggable {
      cursor: grab;
    }
    
    .node-header.dragging {
      opacity: 0.5;
      background-color: #e2e8f0;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    /* Enhanced drag handle styles */
    .drag-handle {
      cursor: grab;
      color: #94a3b8;
      margin-right: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px 4px;
      border-radius: 3px;
      transition: background-color 0.15s ease;
    }
    
    .drag-handle:hover {
      color: #64748b;
      background-color: #e2e8f0;
    }
    
    .drag-handle:active {
      cursor: grabbing;
    }
    
    /* Enhanced drop zone visual indicators */
    .node-header.drag-over-top {
      border-top: 2px solid #3b82f6 !important;
    }
    
    .node-header.drag-over-top::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      height: 4px;
      background-color: rgba(59, 130, 246, 0.3);
      pointer-events: none;
    }
    
    .node-header.drag-over-middle {
      background-color: rgba(59, 130, 246, 0.1);
      border: 2px solid #3b82f6 !important;
    }
    
    .node-header.drag-over-bottom {
      border-bottom: 2px solid #3b82f6 !important;
    }
    
    .node-header.drag-over-bottom::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 4px;
      background-color: rgba(59, 130, 246, 0.3);
      pointer-events: none;
    }
    
    /* Legacy drag-over style for backward compatibility */
    .drag-over {
      border: 2px dashed #3b82f6 !important;
      background-color: #eff6ff;
    }
    
    /* Invalid target indicator */
    .node-header.invalid-target {
      background-color: rgba(220, 38, 38, 0.1);
      border: 2px dashed #dc2626 !important;
    }
    
    /* Visual helper for drag and drop */
    .drag-visual-helper {
      background-color: rgba(59, 130, 246, 0.1);
      border: 1px dashed #3b82f6;
      border-radius: 4px;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: 14px;
      color: #334155;
    }
    
    .drag-visual-helper ul {
      margin: 4px 0 0 0;
      padding-left: 20px;
    }
    
    .drag-visual-helper li {
      margin-bottom: 3px;
    }
    
    /* Animation for smoother visual feedback */
    @keyframes pulse-border {
      0% { border-color: rgba(59, 130, 246, 0.5); }
      50% { border-color: rgba(59, 130, 246, 1); }
      100% { border-color: rgba(59, 130, 246, 0.5); }
    }
    
    .node-header.drag-over-middle {
      animation: pulse-border 1s infinite;
    }
    
    /* Optional tooltip for drag handle */
    .drag-tooltip {
      position: absolute;
      top: 100%;
      right: 0;
      background-color: #334155;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
      width: 220px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    
    .drag-handle:hover .drag-tooltip {
      opacity: 1;
    }
    
    .node-chevron {
      margin-right: 0.25rem;
      transition: transform 0.2s;
    }
    
    .node-chevron.expanded {
      transform: rotate(90deg);
    }
    
    .node-children {
      margin-left: 1.25rem;
      overflow: hidden;
    }
    
    .node-key {
      font-weight: 500;
      margin-right: 0.25rem;
      display: flex;
      align-items: center;
    }
    
    .node-value {
      color: #64748b;
      margin-right: 2.0rem;
      padding: 5px;
      background-color: #f5f1f1;
      margin-left: 5px;
      border-radius: 3px;
    }
    
    .node-value.string {
      color: #16a34a;
    }
    
    .node-value.number {
      color: #2563eb;
    }
    
    .node-value.boolean {
      color: #9333ea;
    }
    
    .node-value.html {
      color: #16a34a;
      cursor: pointer;
      text-decoration: underline;
    }
    
    .node-actions {
      display: flex;
    }
    
    /* Editor */
    .edit-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 10;
    }
    
    .edit-dialog {
      width: 90%;
      max-width: 48rem;
      background-color: white;
      border-radius: 0.5rem;
      overflow: hidden;
    }
    
    .edit-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      background-color: #f1f5f9;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .edit-title {
      font-weight: 600;
      font-size: 1.125rem;
    }
    
    .edit-close {
      color: #64748b;
      cursor: pointer;
    }
    
    .edit-close:hover {
      color: #1e293b;
    }
    
    .edit-content {
      padding: 1rem;
      max-height: 70vh;
      overflow-y: auto;
    }
    
    .edit-footer {
      display: flex;
      justify-content: flex-end;
      padding: 1rem;
      gap: 0.5rem;
      background-color: #f8fafc;
      border-top: 1px solid #e2e8f0;
    }
    
    /* Info text */
    .info-text {
      font-size: 0.875rem;
      color: #64748b;
      margin-top: 0.5rem;
    }

    /* Format selector */
    .format-selector {
      margin-top: 0.5rem;
      display: flex;
      gap: 1rem;
    }

    .radio-group {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .radio-group input[type="radio"] {
      margin: 0;
    }
    
    /* Tooltip styles */
    .help-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background-color: #64748b;
      color: white;
      font-size: 14px;
      cursor: pointer;
      margin-left: 8px;
      vertical-align: middle;
    }

    .tooltip {
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      padding: 10px;
      background-color: #334155;
      color: white;
      border-radius: 4px;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      margin-top: 5px;
      font-size: 13px;
      line-height: 1.5;
    }

    .tooltip p {
      margin-bottom: 8px;
    }

    .tooltip ul {
      padding-left: 20px;
      margin-bottom: 8px;
    }

    .tooltip code {
      background-color: #475569;
      padding: 2px 4px;
      border-radius: 2px;
    }

    /* Rich Text Editor */
    .editor-container {
      height: 300px;
      margin-bottom: 20px;
    }
    
    .quill-editor {
      height: 250px;
      background-color: white;
    }
    
    .ql-editor {
      font-size: 14px;
      line-height: 1.6;
    }
    
    .editor-tabs {
      display: flex;
      margin-bottom: 10px;
    }
    
    .editor-tab {
      padding: 8px 16px;
      background-color: #e2e8f0;
      border: 1px solid #cbd5e1;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    
    .editor-tab.active {
      background-color: white;
      border-bottom: 2px solid #2563eb;
      color: #2563eb;
    }
    
    .editor-view {
      display: none;
    }
    
    .editor-view.active {
      display: block;
    }
    
    /* RTF Preview */
    .rtf-preview {
      margin-top: 20px;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      padding: 16px;
      background-color: white;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .rtf-preview h3 {
      margin-bottom: 12px;
      color: #334155;
    }
    
    /* Icons */
    .icon {
      display: inline-block;
      vertical-align: middle;
      width: 1em;
      height: 1em;
      stroke-width: 0;
      stroke: currentColor;
      fill: currentColor;
    }
    
    /* Hidden */
    .hidden {
      display: none;
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      background-color: #16a34a;
      color: white;
      border-radius: 4px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      transition: transform 0.3s ease, opacity 0.3s ease;
      transform: translateY(100px);
      opacity: 0;
    }

    .toast.visible {
      transform: translateY(0);
      opacity: 1;
    }
    
    .toast.error {
      background-color: #dc2626;
    }
    
    /* Import Panel */
    .import-panel {
      border: 1px solid #cbd5e1;
      border-radius: 0.5rem;
      padding: 1rem;
      background-color: white;
      margin-bottom: 1rem;
    }
    
    .import-panel-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .import-panel-content {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .import-options {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .import-option {
      flex: 1;
      min-width: 200px;
      padding: 1rem;
      border: 1px solid #e2e8f0;
      border-radius: 0.25rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .import-option:hover {
      border-color: #3b82f6;
      background-color: #f8fafc;
    }
    
    .import-option-icon {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
      color: #64748b;
    }
    
    .import-option-title {
      font-weight: 500;
      margin-bottom: 0.25rem;
    }
    
    .import-option-desc {
      font-size: 0.75rem;
      color: #64748b;
    }
    
    /* Document Structure Preview */
    .structure-preview {
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      padding: 0;
      max-height: 400px;
      overflow-y: auto;
      background-color: #f8fafc;
    }
    
    .structure-item {
      display: flex;
      flex-direction: column;
      border-bottom: 1px solid #e2e8f0;
      padding: 0;
    }
    
    .structure-item:last-child {
      border-bottom: none;
    }
    
    .structure-header {
      padding: 8px 12px;
      font-weight: 600;
      background-color: #f1f5f9;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .structure-header-actions {
      display: flex;
      gap: 4px;
    }
    
    .structure-content {
      padding: 8px 12px 8px 24px;
    }
    
    .structure-list {
      list-style-type: disc;
      margin-left: 20px;
    }
    
    .structure-list li {
      margin-bottom: 4px;
    }
    
    .key-input {
      padding: 4px 8px;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      width: 200px;
      font-size: 14px;
    }
  </style> 

</head>
<body>
  <!-- Header -->
  <header>
    <div class="header-title">
      <i class="fas fa-file-alt" style="font-size:24px;"></i>
      Knowledge Base Editor
    </div>
    <div class="header-actions">
      <button id="new-btn" class="btn btn-secondary">
        <i class="material-icons">add_to_photos</i>
        New
      </button>
      <button id="export-btn" class="btn btn-primary">
        <i class="fas fa-download"></i>
        Export
      </button>
    </div>
  </header>
  
  <!-- Main Content -->
  <main>
    <!-- Import Options Panel -->
    <div class="import-panel">
      <div class="import-panel-title">
        <i class="fas fa-file-import"></i>
        Import Knowledge Base
      </div>
      <div class="import-panel-content">
        <div class="import-options">
          <div class="import-option" id="import-js">
            <div class="import-option-icon"><i class="fab fa-js"></i></div>
            <div class="import-option-title">JavaScript File</div>
            <div class="import-option-desc">Import an existing knowledge base JS file</div>
          </div>
          <div class="import-option" id="import-docx">
            <div class="import-option-icon"><i class="fas fa-file-word"></i></div>
            <div class="import-option-title">Word Document</div>
            <div class="import-option-desc">Import from .docx with headings and bullets</div>
          </div>
          <div class="import-option" id="import-rtf">
            <div class="import-option-icon"><i class="fas fa-file-alt"></i></div>
            <div class="import-option-title">Rich Text Format</div>
            <div class="import-option-desc">Import from .rtf with headings and bullets</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- File Drop Area -->
    <div id="drop-zone" class="drop-zone">
      <input type="file" id="file-input" accept=".js,.docx,.rtf" class="hidden">
      <i class="fas fa-cloud-upload-alt" style="font-size:32px;"></i>
      <p class="drop-zone-text">Drag & drop your knowledge base file here</p>
      <p class="drop-zone-subtext">or click to browse</p>
      <p class="info-text">Supports JS, DOCX, and RTF files</p>
    </div>
    
    <!-- Filename Input -->
    <div class="filename-container">
      <label for="filename" class="filename-label">Filename:</label>
      <input type="text" id="filename" value="knowledge-base.js" class="filename-input">
    </div>
    
    <!-- Export Format Selection -->
    <div class="format-selector">
      <label class="filename-label">Export Format:</label>
      <div class="radio-group">
        <input type="radio" id="format-module" name="export-format" value="module">
        <label for="format-module">ES6 Module (export default)</label>
      </div>
      <div class="radio-group">
        <input type="radio" id="format-const" name="export-format" value="const" checked>
        <label for="format-const">Const declaration</label>
      </div>
    </div>
    
    <!-- Tree View -->
    <div class="card">
      <div id="tree-container" class="tree-view"></div>
    </div>
  </main>
  
  <!-- Edit Modal with Rich Text Editor -->
  <div id="edit-modal" class="edit-modal hidden">
    <div class="edit-dialog">
      <div class="edit-header">
        <h2 class="edit-title">Edit Value</h2>
        <span class="edit-close">✕</span>
      </div>
      <div class="edit-content">
        <div class="form-group">
          <label for="edit-key">Property Name:</label>
          <input type="text" id="edit-key" placeholder="Enter a name for this property">
        </div>
        <div class="form-group" id="value-form-group">
          <label for="edit-value">Value:</label>
          
          <!-- Editor Tabs -->
          <div class="editor-tabs">
            <div class="editor-tab active" data-tab="rich-text">Rich Text</div>
            <div class="editor-tab" data-tab="raw-text">Raw Text</div>
          </div>
          
          <!-- Rich Text Editor -->
          <div class="editor-view active" id="rich-text-view">
            <div id="quill-editor" class="quill-editor"></div>
          </div>
          
          <!-- Raw Text Editor -->
          <div class="editor-view" id="raw-text-view">
            <textarea id="edit-value" placeholder="Enter the value"></textarea>
          </div>
        </div>
        <div class="form-group">
          <label for="edit-type">Value Type:</label>
          <select id="edit-type">
            <option value="string">Text (words, phrases, paragraphs)</option>
            <option value="richtext">Rich Text (formatted content with headings, bullets)</option>
            <option value="number">Number (like 1, 2.5, -10)</option>
            <option value="boolean">Yes/No (true or false)</option>
            <option value="array">List of Items (collection)</option>
            <option value="object">Group of Properties (container)</option>
          </select>
        </div>
      </div>
      <div class="edit-footer">
        <button id="edit-cancel-btn" class="btn btn-secondary">Cancel</button>
        <button id="edit-save-btn" class="btn btn-primary">Save</button>
      </div>
    </div>
  </div>

  <!-- Document Structure Preview Modal -->
  <div id="document-preview-modal" class="edit-modal hidden">
    <div class="edit-dialog">
      <div class="edit-header">
        <h2 class="edit-title">Document Structure Preview</h2>
        <span class="edit-close" id="document-preview-close">✕</span>
      </div>
      <div class="edit-content">
        <p>Review and customize how your document will be imported. Modify the property keys as needed.</p>
        <div class="structure-preview" id="document-structure-preview">
          <!-- Structure content will be inserted here -->
        </div>
      </div>
      <div class="edit-footer">
        <button id="doc-cancel-btn" class="btn btn-secondary">Cancel</button>
        <button id="doc-import-btn" class="btn btn-primary">Import Structure</button>
      </div>
    </div>
  </div>

  <!-- Toast Notification -->
  <div id="toast" class="toast">
    <span id="toast-message"></span>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // State
      let knowledgeBase = {};
      let expandedNodes = {};
      let editPath = [];
      let editMode = 'edit'; // 'edit', 'add'
      let draggedNode = null;
      let draggedNodePath = null;
      let documentStructure = null;
      let quillEditor = null;
      
      // DOM Elements
      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('file-input');
      const filenameInput = document.getElementById('filename');
      const treeContainer = document.getElementById('tree-container');
      const newBtn = document.getElementById('new-btn');
      const exportBtn = document.getElementById('export-btn');
      const formatModule = document.getElementById('format-module');
      const formatConst = document.getElementById('format-const');
      const toast = document.getElementById('toast');
      const toastMessage = document.getElementById('toast-message');
      
      // Import option elements
      const importJs = document.getElementById('import-js');
      const importDocx = document.getElementById('import-docx');
      const importRtf = document.getElementById('import-rtf');
      
      // Document preview elements
      const documentPreviewModal = document.getElementById('document-preview-modal');
      const documentStructurePreview = document.getElementById('document-structure-preview');
      const documentPreviewClose = document.getElementById('document-preview-close');
      const docCancelBtn = document.getElementById('doc-cancel-btn');
      const docImportBtn = document.getElementById('doc-import-btn');
      
      // Modal elements
      const editModal = document.getElementById('edit-modal');
      const editKey = document.getElementById('edit-key');
      const editValue = document.getElementById('edit-value');
      const editType = document.getElementById('edit-type');
      const editCloseBtn = document.querySelector('.edit-close');
      const editCancelBtn = document.getElementById('edit-cancel-btn');
      const editSaveBtn = document.getElementById('edit-save-btn');
      const valueFormGroup = document.getElementById('value-form-group');
      
      // Editor tabs
      const editorTabs = document.querySelectorAll('.editor-tab');
      const editorViews = document.querySelectorAll('.editor-view');
      
      // Initialize Quill editor
      quillEditor = new Quill('#quill-editor', {
        theme: 'snow',
        modules: {
          toolbar: [
            ['bold', 'italic', 'underline', 'strike'],
            ['blockquote', 'code-block'],
            [{ 'header': 1 }, { 'header': 2 }],
            [{ 'list': 'ordered'}, { 'list': 'bullet' }],
            [{ 'indent': '-1'}, { 'indent': '+1' }],
            ['link'],
            ['clean']
          ]
        },
        placeholder: 'Enter formatted content here...'
      });
      
      // Event Listeners
      
      // Import option clicks
      importJs.addEventListener('click', () => {
        fileInput.accept = '.js';
        fileInput.click();
      });
      
      importDocx.addEventListener('click', () => {
        fileInput.accept = '.docx';
        fileInput.click();
      });
      
      importRtf.addEventListener('click', () => {
        fileInput.accept = '.rtf';
        fileInput.click();
      });
      
      // Document preview modal events
      documentPreviewClose.addEventListener('click', closeDocumentPreviewModal);
      docCancelBtn.addEventListener('click', closeDocumentPreviewModal);
      docImportBtn.addEventListener('click', importDocumentStructure);
      
      // Tab switching
      editorTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // Deactivate all tabs
          editorTabs.forEach(t => t.classList.remove('active'));
          editorViews.forEach(v => v.classList.remove('active'));
          
          // Activate the clicked tab
          tab.classList.add('active');
          const tabId = tab.getAttribute('data-tab');
          document.getElementById(`${tabId}-view`).classList.add('active');
          
          // Sync content between editors when switching tabs
          if (tabId === 'rich-text') {
            const content = editValue.value;
            quillEditor.root.innerHTML = content;
          } else if (tabId === 'raw-text') {
            editValue.value = quillEditor.root.innerHTML;
          }
        });
      });
      
      // Drop zone events
      dropZone.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', handleFileSelect);
      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('dragleave', handleDragLeave);
      dropZone.addEventListener('drop', handleDrop);
      
      // Button events
      newBtn.addEventListener('click', createNew);
      exportBtn.addEventListener('click', exportKnowledgeBase);
      
      // Modal event listeners
      editCloseBtn.addEventListener('click', closeEditModal);
      editCancelBtn.addEventListener('click', closeEditModal);
      editSaveBtn.addEventListener('click', saveEdit);
      
      // Value type change listener
      editType.addEventListener('change', function() {
        const valueType = this.value;
        
        // Show/hide rich text editor based on type
        if (valueType === 'richtext' || valueType === 'string') {
          document.querySelector('.editor-tabs').style.display = 'flex';
          if (valueType === 'richtext') {
            document.querySelector('[data-tab="rich-text"]').click(); // Show rich text tab
          }
        } else {
          document.querySelector('[data-tab="raw-text"]').click(); // Show raw text tab
          document.querySelector('.editor-tabs').style.display = 'none';
        }
      });
      
      // Toast notification function
      function showToast(message, type = 'success', duration = 3000) {
        toastMessage.textContent = message;
        toast.classList.remove('error');
        
        if (type === 'error') {
          toast.classList.add('error');
        }
        
        toast.classList.add('visible');
        
        setTimeout(() => {
          toast.classList.remove('visible');
        }, duration);
      }
      
      // Init
      createNew();
      addDragAndDropHelper();
      
      // Handlers
      function handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.add('active');
      }
      
      function handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('active');
      }
      
      function handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('active');
        
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
          const file = e.dataTransfer.files[0];
          handleFile(file);
        }
      }
      
      function handleFileSelect(e) {
        if (e.target.files && e.target.files[0]) {
          const file = e.target.files[0];
          handleFile(file);
        }
      }
      
      function handleFile(file) {
        filenameInput.value = file.name;
        const fileExt = file.name.split('.').pop().toLowerCase();
        
        if (fileExt === 'js') {
          // Handle JavaScript file
          handleJsFile(file);
        } else if (fileExt === 'docx') {
          // Handle Word document
          handleDocxFile(file);
        } else if (fileExt === 'rtf') {
          // Handle RTF file
          handleRtfFile(file);
        } else {
          showToast('Unsupported file type. Please upload a .js, .docx, or .rtf file.', 'error');
        }
      }
      
      function handleJsFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const content = e.target.result;
            
            // Try to match "export default {...}" pattern
            let match = content.match(/export\s+default\s+(\{[\s\S]*\});?\s*$/);
            
            if (match && match[1]) {
              // ES6 module format
              const parsed = new Function(`return ${match[1]}`)();
              knowledgeBase = parsed;
              updateUI();
              formatModule.checked = true;
              showToast("JavaScript file loaded successfully!");
              return;
            }
            
            // Try to match "const varName = {...}" pattern
            match = content.match(/const\s+(\w+)\s*=\s*(\{[\s\S]*\});/);
            
            if (match && match[2]) {
              // Const declaration format
              const parsed = new Function(`return ${match[2]}`)();
              knowledgeBase = parsed;
              updateUI();
              formatConst.checked = true;
              const varName = match[1];
              filenameInput.value = varName + '.js';
              showToast("JavaScript file loaded successfully!");
              return;
            }
            
            // Try to extract any JavaScript object
            match = content.match(/(\{[\s\S]*\})/);
            
            if (match && match[1]) {
              try {
                const parsed = new Function(`return ${match[1]}`)();
                if (typeof parsed === 'object' && parsed !== null) {
                  knowledgeBase = parsed;
                  updateUI();
                  showToast("JavaScript file loaded successfully!");
                  return;
                }
              } catch (err) {
                console.error("Error parsing object:", err);
              }
            }
            
            throw new Error("Could not parse file format");
          } catch (error) {
            console.error("Error parsing file:", error);
            showToast("Error parsing JavaScript file. Please make sure it's valid.", "error");
          }
        };
        
        reader.readAsText(file);
      }
      
      function handleDocxFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const arrayBuffer = e.target.result;
          
          // Use mammoth.js to convert docx to HTML
          mammoth.convertToHtml({ arrayBuffer })
            .then(function(result) {
              // Process the HTML content to extract structure
              const htmlContent = result.value;
              parseDocumentStructure(htmlContent);
            })
            .catch(function(error) {
              console.error("Error converting DOCX:", error);
              showToast("Error processing Word document. Please check the file format.", "error");
            });
        };
        
        reader.readAsArrayBuffer(file);
      }
      
      function handleRtfFile(file) {
        // Since RTF parsing in browser is limited, we'll use a two-stage approach:
        // 1. Try to extract text with basic formatting using FileReader
        // 2. Process the text to identify headings and list items
        
        const reader = new FileReader();
        reader.onload = function(e) {
          const text = e.target.result;
          try {
            parseRtfStructure(text);
          } catch (error) {
            console.error("Error parsing RTF:", error);
            showToast("Error processing RTF file. Try uploading a DOCX file instead.", "error");
          }
        };
        
        reader.readAsText(file);
      }
      
      function parseRtfStructure(rtfContent) {
        // This is a simplified approach to parse RTF content
        // It looks for patterns that may indicate headings and bullet points
        
        // Split the content into lines
        const lines = rtfContent.split('\n');
        const structure = [];
        
        let currentSection = null;
        let inList = false;
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // Skip empty lines
          if (!line) continue;
          
          // Check if line contains RTF control codes (simplistic approach)
          const hasControlCodes = line.includes('\\') && (line.includes('\\f') || line.includes('\\par'));
          
          // Clean the line from RTF control codes (very simplistic)
          let cleanLine = line.replace(/\\\w+\s?/g, '').replace(/[{}]/g, '').trim();
          
          // Skip if line is still empty after cleaning
          if (!cleanLine) continue;
          
          // Heading detection heuristics
          // - Line is short (less than 60 chars)
          // - Line ends with a colon or doesn't end with punctuation
          // - Line has different formatting (e.g., starts with \b for bold)
          const isHeading = 
            (cleanLine.length < 60 && 
             (cleanLine.endsWith(':') || !/[.,:;!?]$/.test(cleanLine))) ||
            line.includes('\\b ') ||
            line.includes('\\fs') && 
            !line.includes('\\bullet');
          
          // Bullet point detection
          const isBullet = 
            line.includes('\\bullet') || 
            line.includes('\\listtext') ||
            cleanLine.startsWith('•') || 
            cleanLine.startsWith('-') || 
            cleanLine.startsWith('*') ||
            /^\d+[\.\)]/.test(cleanLine);
          
          if (isHeading && !isBullet) {
            // Save previous section if it exists
            if (currentSection) {
              structure.push(currentSection);
            }
            
            // Start a new section
            currentSection = {
              heading: cleanLine,
              content: [],
              key: convertToKey(cleanLine)
            };
            
            inList = false;
          } else if (isBullet || inList) {
            // Process bullet point
            inList = true;
            
            // Clean bullet prefixes
            cleanLine = cleanLine.replace(/^[•\-*]\s*/, '').replace(/^\d+[\.\)]\s*/, '').trim();
            
            if (currentSection && cleanLine) {
              currentSection.content.push(cleanLine);
            }
          } else if (currentSection) {
            // Regular paragraph - could be continuation of the heading or a standalone paragraph
            // For simplicity, we'll add it to the current section
            currentSection.content.push(cleanLine);
          }
        }
        
        // Add the last section if it exists
        if (currentSection) {
          structure.push(currentSection);
        }
        
        // If no structure could be extracted, show an error
        if (structure.length === 0) {
          showToast("Could not extract structure from RTF file. Try a different format or file.", "error");
          return;
        }
        
        // Store the structure and show preview
        documentStructure = structure;
        showDocumentStructurePreview();
      }
      
      function parseDocumentStructure(htmlContent) {
        // Create a DOM parser to work with the HTML content
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, 'text/html');
        
        // Extract headings and their content
        const headings = doc.querySelectorAll('h1, h2, h3, h4, h5, h6');
        const structure = [];
        
        headings.forEach((heading, index) => {
          const headingText = heading.textContent.trim();
          
          // Skip empty headings
          if (!headingText) return;
          
          const content = [];
          
          // Get all content until the next heading
          let currentElement = heading.nextElementSibling;
          
          while (currentElement && !currentElement.matches('h1, h2, h3, h4, h5, h6')) {
            // Process lists specially
            if (currentElement.matches('ul, ol')) {
              const listItems = currentElement.querySelectorAll('li');
              listItems.forEach(item => {
                if (item.textContent.trim()) {
                  content.push(item.textContent.trim());
                }
              });
            } 
            // Process paragraphs
            else if (currentElement.matches('p')) {
              if (currentElement.textContent.trim()) {
                content.push(currentElement.textContent.trim());
              }
            }
            
            currentElement = currentElement.nextElementSibling;
          }
          
          structure.push({
            heading: headingText,
            content: content,
            key: convertToKey(headingText)
          });
        });
        
        // If no structure could be extracted, show an error
        if (structure.length === 0) {
          showToast("Could not extract structure from DOCX file. Ensure it has headings.", "error");
          return;
        }
        
        // Store the structure and show preview
        documentStructure = structure;
        showDocumentStructurePreview();
      }
      
      function convertToKey(text) {
        // Convert a heading text to a valid JS object key
        return text
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '')
          .replace(/_+/g, '_');
      }
      
      function showDocumentStructurePreview() {
        if (!documentStructure || documentStructure.length === 0) {
          return;
        }
        
        // Clear the preview container
        documentStructurePreview.innerHTML = '';
        
        // Create preview elements for each section
        documentStructure.forEach((section, index) => {
          const sectionElement = document.createElement('div');
          sectionElement.className = 'structure-item';
          
          // Section header with editable key
          const headerElement = document.createElement('div');
          headerElement.className = 'structure-header';
          
          const headerContent = document.createElement('div');
          headerContent.textContent = section.heading;
          
          const keyInput = document.createElement('input');
          keyInput.type = 'text';
          keyInput.className = 'key-input';
          keyInput.value = section.key;
          keyInput.setAttribute('data-index', index);
          keyInput.addEventListener('input', (e) => {
            documentStructure[index].key = e.target.value;
          });
          
          headerElement.appendChild(headerContent);
          headerElement.appendChild(keyInput);
          
          sectionElement.appendChild(headerElement);
          
          // Section content with list items
          if (section.content.length > 0) {
            const contentElement = document.createElement('div');
            contentElement.className = 'structure-content';
            
            const listElement = document.createElement('ul');
            listElement.className = 'structure-list';
            
            section.content.forEach(item => {
              const listItem = document.createElement('li');
              listItem.textContent = item;
              listElement.appendChild(listItem);
            });
            
            contentElement.appendChild(listElement);
            sectionElement.appendChild(contentElement);
          }
          
          documentStructurePreview.appendChild(sectionElement);
        });
        
        // Show the preview modal
        documentPreviewModal.classList.remove('hidden');
      }
      
      function closeDocumentPreviewModal() {
        documentPreviewModal.classList.add('hidden');
      }
      
      function importDocumentStructure() {
        if (!documentStructure || documentStructure.length === 0) {
          closeDocumentPreviewModal();
          return;
        }
        
        // Convert document structure to knowledge base format
        let importedStructure = {};
        
        documentStructure.forEach(section => {
          const key = section.key;
          
          // Skip if key is empty
          if (!key) return;
          
          // Create content array from bullet points
          const contentArray = section.content.map(item => item);
          
          // Store in the imported structure
          importedStructure[key] = {
            title: section.heading,
            description: section.content.length > 0 ? section.content[0] : '',
            items: contentArray
          };
        });
        
        // Merge with existing knowledge base or replace it
        if (Object.keys(knowledgeBase).length === 0) {
          // New knowledge base
          knowledgeBase = {
            title: 'Imported Knowledge Base',
            description: 'Imported from document',
            ...importedStructure
          };
        } else {
          // Add to existing knowledge base
          Object.keys(importedStructure).forEach(key => {
            knowledgeBase[key] = importedStructure[key];
          });
        }
        
        // Update the UI
        updateUI();
        closeDocumentPreviewModal();
        showToast("Document structure imported successfully!");
      }
      
      function createNew() {
        const confirm = window.confirm("This will clear the current knowledge base. Continue?");
        if (confirm) {
          knowledgeBase = {
            title: 'New Knowledge Base',
            description: 'Knowledge base description',
            llmInstructions: '<h3>Instructions for the LLM</h3><p>Provide clear step-by-step instructions for the language model on how to use this knowledge base.</p><h4>Key Principles</h4><ul><li>Use structured analysis approach</li><li>Provide detailed explanations</li><li>Follow specified formats</li></ul><h4>Evaluation Process</h4><ol><li>First, analyze the provided input</li><li>Next, apply heuristic principles</li><li>Finally, provide actionable recommendations</li></ol>',
            userInstructions: '<h3>How to Use This Knowledge Base</h3><p>Follow these guidelines for best results.</p><h4>Effective Queries</h4><ul><li>Upload screenshots of your interface for evaluation</li><li>Ask specific questions like "Analyze this form for accessibility issues"</li><li>Request specific formats: "Provide analysis in table format"</li></ul><h4>Sample Interactions</h4><ol><li>"Evaluate this checkout flow for usability problems"</li><li>"What specific improvements would make this design more inclusive?"</li></ol>',
            categories: []
          };
          expandedNodes = {};
          filenameInput.value = 'knowledge-base.js';
          updateUI();
          showToast("New knowledge base created!");
        }
      }
      
      function exportKnowledgeBase() {
        // Format the knowledge base object as a string
        const formatObject = (obj, indent = 0) => {
          const spacing = ' '.repeat(indent);
          
          if (Array.isArray(obj)) {
            if (obj.length === 0) return '[]';
            
            // Check if array contains simple values
            const hasComplexItems = obj.some(item => typeof item === 'object' && item !== null);
            
            if (!hasComplexItems) {
              // Format arrays of primitives on one line with double quotes for strings
              const items = obj.map(item => typeof item === 'string' ? `"${item.replace(/"/g, '\\"')}"` : item);
              return `[${items.join(', ')}]`;
            }
            
            // Format arrays of objects with proper indentation
            let result = '[\n';
            obj.forEach((item, index) => {
              if (typeof item === 'object' && item !== null) {
                result += `${spacing}  ${formatObject(item, indent + 2)}`;
              } else if (typeof item === 'string') {
                result += `${spacing}  "${item.replace(/"/g, '\\"')}"`;
              } else {
                result += `${spacing}  ${item}`;
              }
              
              if (index < obj.length - 1) result += ',';
              result += '\n';
            });
            result += `${spacing}]`;
            return result;
          }
          
          if (typeof obj !== 'object' || obj === null) {
            if (typeof obj === 'string') {
              // For strings with HTML, we need to handle new lines and quotes carefully
              const lines = obj.split('\n');
              if (lines.length > 1 || obj.includes('<')) {
                return `\`${obj.replace(/`/g, '\\`')}\``;
              }
              return `"${obj.replace(/"/g, '\\"')}"`;
            }
            return String(obj);
          }
          
          const keys = Object.keys(obj);
          if (keys.length === 0) return '{}';
          
          let result = '{\n';
          
          keys.forEach((key, index) => {
            const value = obj[key];
            result += `${spacing}  "${key}": `;
            
            if (typeof value === 'object' && value !== null) {
              result += formatObject(value, indent + 2);
            } else if (typeof value === 'string') {
              // For strings with HTML, we need to handle new lines and quotes carefully
              const lines = value.split('\n');
              if (lines.length > 1 || value.includes('<')) {
                result += `\`${value.replace(/`/g, '\\`')}\``;
              } else {
                result += `"${value.replace(/"/g, '\\"')}"`;
              }
            } else {
              result += value;
            }
            
            if (index < keys.length - 1) result += ',';
            result += '\n';
          });
          
          result += `${spacing}}`;
          return result;
        };
        
        let jsContent;
        const baseFileName = filenameInput.value.replace(/\.js$/, '');
        const varName = baseFileName.replace(/[^a-zA-Z0-9_]/g, '_') || 'knowledgeBase';
        
        if (formatModule.checked) {
          // ES6 module format
          jsContent = `export default ${formatObject(knowledgeBase)};`;
        } else {
          // Const declaration format
          jsContent = `/**
 * ${knowledgeBase.title || 'Knowledge Base'}
 * JavaScript module format for easy importing
 */
const ${varName}Data = ${formatObject(knowledgeBase)};

// Make the data available globally
window.${varName}Data = ${varName}Data;`;
        }
        
        // Create a blob and download link
        const blob = new Blob([jsContent], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filenameInput.value;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        showToast("File exported successfully!");
      }
      
      // Tree view functions
      function updateUI() {
        renderTree();
      }
      
      function renderTree() {
        treeContainer.innerHTML = '';
        
        // Check if knowledgeBase is empty
        if (Object.keys(knowledgeBase).length === 0) {
          const emptyNode = document.createElement('div');
          emptyNode.className = 'node-empty';
          emptyNode.textContent = 'No data yet. Import a file or add properties.';
          treeContainer.appendChild(emptyNode);
          
          // Add root level add button
          const addRootBtn = document.createElement('button');
          addRootBtn.className = 'btn btn-small btn-success';
          addRootBtn.innerHTML = '<i class="material-icons">add_to_photos</i> Add Property';
          addRootBtn.addEventListener('click', () => showAddModal([]));
          treeContainer.appendChild(addRootBtn);
          
          return;
        }
        
        // Render each root level property
        Object.entries(knowledgeBase).forEach(([key, value]) => {
          const nodeElement = createTreeNode(key, value, [key]);
          treeContainer.appendChild(nodeElement);
        });
        
        // Add root level add button
        const addRootBtn = document.createElement('button');
        addRootBtn.className = 'btn btn-small btn-success';
        addRootBtn.style.marginTop = '0.5rem';
        addRootBtn.innerHTML = '<i class="material-icons">add_to_photos</i> Add Property';
        addRootBtn.addEventListener('click', () => showAddModal([]));
        treeContainer.appendChild(addRootBtn);
      }
      
      function createTreeNode(key, value, path) {
        const nodeElement = document.createElement('div');
        nodeElement.className = 'tree-node';
        nodeElement.dataset.path = JSON.stringify(path);
        
        // Find the part where you create the nodeHeader and add event listeners
        const nodeHeader = document.createElement('div');
        nodeHeader.className = 'node-header draggable';
        nodeHeader.draggable = true;

        // Set up drag events for enhanced functionality
        nodeHeader.addEventListener('dragstart', (e) => handleDragStart(e, path));
        nodeHeader.addEventListener('dragover', (e) => handleNodeDragOver(e, path));
        nodeHeader.addEventListener('dragleave', (e) => handleNodeDragLeave(e));
        nodeHeader.addEventListener('drop', (e) => handleNodeDrop(e, path));
        nodeHeader.addEventListener('dragend', (e) => handleDragEnd(e));
        
        // Add drag handle
        const dragHandle = document.createElement('div');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '<i class="fas fa-grip-vertical"></i>';
        nodeHeader.appendChild(dragHandle);
        
        // Determine node type and expandability
        const isExpandable = typeof value === 'object' && value !== null && Object.keys(value).length > 0;
        const pathKey = path.join('.');
        const isExpanded = expandedNodes[pathKey] || false;
        
        // Create chevron or spacer
        if (isExpandable) {
          const chevron = document.createElement('span');
          chevron.className = `node-chevron ${isExpanded ? 'expanded' : ''}`;
          chevron.innerHTML = '<i class="fas fa-chevron-right"></i>';
          nodeHeader.appendChild(chevron);
        } else {
          const spacer = document.createElement('span');
          spacer.style.width = '16px';
          spacer.style.display = 'inline-block';
          nodeHeader.appendChild(spacer);
        }
        
        // Key name & value wrapper
        const keyValueWrapper = document.createElement('div');
        keyValueWrapper.className = 'node-key';
        
        const keyElement = document.createElement('span');
        keyElement.textContent = key;
        keyValueWrapper.appendChild(keyElement);
        
        // Value preview
        if (!isExpandable) {
          const valueElement = document.createElement('span');
          
          // Detect if it's an HTML string
          const isHtmlString = typeof value === 'string' && (
            value.startsWith('<') || 
            value.includes('</') || 
            value.includes('<p>') || 
            value.includes('<h')
          );
          
          if (isHtmlString) {
            valueElement.className = 'node-value html';
            valueElement.textContent = "HTML Content (click to view)";
            valueElement.addEventListener('click', (e) => {
              e.stopPropagation();
              showHtmlPreview(key, value);
            });
          } else if (typeof value === 'string') {
            valueElement.className = 'node-value string';
            valueElement.textContent = `"${value.length > 50 ? value.substring(0, 47) + '...' : value}"`;
          } else if (value === null) {
            valueElement.className = 'node-value';
            valueElement.textContent = 'null';
          } else {
            valueElement.className = `node-value ${typeof value}`;
            valueElement.textContent = String(value);
          }
          
          keyValueWrapper.appendChild(valueElement);
        } else if (Array.isArray(value)) {
          const previewElement = document.createElement('span');
          previewElement.className = 'node-value';
          previewElement.textContent = `List with ${value.length} item${value.length !== 1 ? 's' : ''}`;
          keyValueWrapper.appendChild(previewElement);
        } else {
          const previewElement = document.createElement('span');
          previewElement.className = 'node-value';
          previewElement.textContent = `Group with ${Object.keys(value).length} propert${Object.keys(value).length !== 1 ? 'ies' : 'y'}`;
          keyValueWrapper.appendChild(previewElement);
        }
        
        nodeHeader.appendChild(keyValueWrapper);
        
        // Action buttons
        const actionsElement = document.createElement('div');
        actionsElement.className = 'node-actions';
        
        const editBtn = document.createElement('button');
        editBtn.className = 'btn-icon edit';
        editBtn.title = 'Edit';
        editBtn.innerHTML = '<i class="far fa-edit" style="font-size:17px"></i>';
        editBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          showEditModal(path);
        });
        actionsElement.appendChild(editBtn);
        
        if (isExpandable) {
          const addBtn = document.createElement('button');
          addBtn.className = 'btn-icon add';
          addBtn.title = 'Add Item';
          addBtn.innerHTML = '<i class="material-icons" style="font-size:20px">add_to_photos</i>';
          addBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showAddModal(path);
          });
          actionsElement.appendChild(addBtn);
        }
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn-icon delete';
        deleteBtn.title = 'Delete';
        deleteBtn.innerHTML = '<i class="far fa-trash-alt" style="font-size:17px"></i>';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          deleteNode(path);
        });
        actionsElement.appendChild(deleteBtn);
        
        nodeHeader.appendChild(actionsElement);
        
        // Toggle expand/collapse on click
        if (isExpandable) {
          nodeHeader.addEventListener('click', (e) => {
            // Only toggle if not clicking a button
            if (!e.target.closest('button')) {
              toggleNodeExpand(path);
            }
          });
        }
        
        nodeElement.appendChild(nodeHeader);
        
        // Children container
        if (isExpandable) {
          const childrenContainer = document.createElement('div');
          childrenContainer.className = `node-children ${isExpanded ? '' : 'hidden'}`;
          
          if (isExpanded) {
            if (Array.isArray(value)) {
              value.forEach((item, index) => {
                const childNode = createTreeNode(index.toString(), item, [...path, index]);
                childrenContainer.appendChild(childNode);
              });
            } else {
              Object.entries(value).forEach(([childKey, childValue]) => {
                const childNode = createTreeNode(childKey, childValue, [...path, childKey]);
                childrenContainer.appendChild(childNode);
              });
            }
          }
          
          nodeElement.appendChild(childrenContainer);
        }
        
        return nodeElement;
      }
      
      function showHtmlPreview(key, htmlContent) {
        // Use the document preview modal to show HTML content
        documentStructurePreview.innerHTML = `
          <div class="structure-item">
            <div class="structure-header">${key}</div>
            <div class="structure-content">${htmlContent}</div>
          </div>
        `;
        
        // Show the modal
        documentPreviewModal.classList.remove('hidden');
        docImportBtn.style.display = 'none';
        docCancelBtn.textContent = 'Close';
        
        // Add close event
        documentPreviewClose.addEventListener('click', function() {
          documentPreviewModal.classList.add('hidden');
          docImportBtn.style.display = 'block';
          docCancelBtn.textContent = 'Cancel';
        });
        
        docCancelBtn.addEventListener('click', function() {
          documentPreviewModal.classList.add('hidden');
          docImportBtn.style.display = 'block';
          docCancelBtn.textContent = 'Cancel';
        });
      }
      
      // Drag and drop handlers
      function handleDragStart(e, path) {
        draggedNode = e.target;
        draggedNodePath = path;
        draggedNode.classList.add('dragging');
        
        // Store data about the dragged item
        e.dataTransfer.setData("text/plain", JSON.stringify(path));
        e.dataTransfer.effectAllowed = "move";
      }
      
      function handleNodeDragOver(e, targetPath) {
  e.preventDefault();
  
  // Prevent drag over itself
  if (JSON.stringify(draggedNodePath) === JSON.stringify(targetPath)) {
    return;
  }
  
  // Prevent drag into its own children
  if (isChildOf(targetPath, draggedNodePath)) {
    e.currentTarget.classList.add('invalid-target');
    return;
  }
  
  // Determine drop position (top, middle, bottom)
  const rect = e.currentTarget.getBoundingClientRect();
  const y = e.clientY;
  const topThreshold = rect.top + rect.height * 0.25;
  const bottomThreshold = rect.top + rect.height * 0.75;
  
  // Remove all drop position classes first
  e.currentTarget.classList.remove('drag-over-top', 'drag-over-middle', 'drag-over-bottom', 'drag-over');
  
  // Add appropriate class based on position
  if (y < topThreshold) {
    e.currentTarget.classList.add('drag-over-top');
  } else if (y > bottomThreshold) {
    e.currentTarget.classList.add('drag-over-bottom');
  } else {
    e.currentTarget.classList.add('drag-over-middle');
  }
  
  e.dataTransfer.dropEffect = "move";
}

function handleNodeDragLeave(e) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over-top', 'drag-over-middle', 'drag-over-bottom', 'drag-over', 'invalid-target');
}

function handleNodeDrop(e, targetPath) {
  e.preventDefault();
  e.stopPropagation();
  
  // Clean up classes
  e.currentTarget.classList.remove('drag-over-top', 'drag-over-middle', 'drag-over-bottom', 'drag-over', 'invalid-target');
  
  // Prevent drop on itself
  if (JSON.stringify(draggedNodePath) === JSON.stringify(targetPath)) {
    return;
  }
  
  // Prevent drop into its own children
  if (isChildOf(targetPath, draggedNodePath)) {
    return;
  }
  
  // Determine drop position
  const rect = e.currentTarget.getBoundingClientRect();
  const y = e.clientY;
  const topThreshold = rect.top + rect.height * 0.25;
  const bottomThreshold = rect.top + rect.height * 0.75;
  let position = 'middle'; // Default is to drop inside the target
  
  if (y < topThreshold) {
    position = 'before';
  } else if (y > bottomThreshold) {
    position = 'after';
  }
  
  moveNode(draggedNodePath, targetPath, position);
}
      
https://claude.ai/chat/76a63ba3-d7d2-4620-8739-5a974535a4b7#:~:text=function%20handleDragEnd(e,draggedNodePath%20=%20null;}
      
      // Helper function to check if target is a child of source
      function isChildOf(targetPath, sourcePath) {
        if (targetPath.length <= sourcePath.length) {
          return false;
        }
        
        for (let i = 0; i < sourcePath.length; i++) {
          if (targetPath[i] !== sourcePath[i]) {
            return false;
          }
        }
        
        return true;
      }

      function moveNode(sourcePath, targetPath, position = 'middle') {
  try {
    // Get source value and key
    const sourceValue = getValueAtPath(knowledgeBase, sourcePath);
    const sourceKey = sourcePath[sourcePath.length - 1];
    
    // Get parent paths and objects
    const sourceParentPath = sourcePath.slice(0, -1);
    const sourceParent = sourceParentPath.length > 0 
      ? getValueAtPath(knowledgeBase, sourceParentPath) 
      : knowledgeBase;
    
    const targetParentPath = targetPath.slice(0, -1);
    const targetParent = targetParentPath.length > 0 
      ? getValueAtPath(knowledgeBase, targetParentPath) 
      : knowledgeBase;
    
    const targetKey = targetPath[targetPath.length - 1];
    const targetValue = getValueAtPath(knowledgeBase, targetPath);
    
    // Handle based on position
    if (position === 'middle') {
      // Middle: Insert as a child of the target node
      if (typeof targetValue === 'object' && targetValue !== null) {
        // Delete the source
        deleteValueAtPath(knowledgeBase, sourcePath);
        
        // Add to target object/array
        if (Array.isArray(targetValue)) {
          targetValue.push(sourceValue);
        } else {
          targetValue[sourceKey] = sourceValue;
        }
      } else {
        showToast("Cannot insert inside a non-object node", "error");
        return;
      }
    } else if (position === 'before' || position === 'after') {
      // Before/After: Insert as a sibling of the target node
      
      // If source and target have the same parent
      const sameParent = JSON.stringify(sourceParentPath) === JSON.stringify(targetParentPath);
      
      // For arrays, handle indexes correctly
      if (Array.isArray(targetParent)) {
        // Get the target index
        const targetIndex = parseInt(targetKey);
        
        // Calculate the insertion index
        let insertIndex = position === 'before' ? targetIndex : targetIndex + 1;
        
        // Get the source index
        const sourceIndex = parseInt(sourceKey);
        
        // If source comes before target in the same array, adjust the insert index
        if (sameParent && sourceIndex < insertIndex) {
          insertIndex--;
        }
        
        // Delete the source (only if not in the same parent or we'll adjust indices later)
        if (!sameParent) {
          deleteValueAtPath(knowledgeBase, sourcePath);
        }
        
        // Remove from current position if same parent
        if (sameParent) {
          sourceParent.splice(sourceIndex, 1);
          
          // Adjust insert index if needed after removal
          if (sourceIndex < insertIndex) {
            insertIndex--;
          }
        }
        
        // Insert at the new position
        targetParent.splice(insertIndex, 0, sourceValue);
      } else {
        // For objects, we need to reorder properties
        
        // Delete the source
        deleteValueAtPath(knowledgeBase, sourcePath);
        
        // For objects, we can't insert "before" or "after" directly
        // So we rebuild the object with the desired order
        const newObject = {};
        const keys = Object.keys(targetParent);
        
        // Insert at appropriate position
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          
          // Insert source item before target
          if (position === 'before' && key === targetKey) {
            newObject[sourceKey] = sourceValue;
          }
          
          // Add the current key (unless it's the sourceKey in the same parent)
          if (!(sameParent && key === sourceKey)) {
            newObject[key] = targetParent[key];
          }
          
          // Insert source item after target
          if (position === 'after' && key === targetKey) {
            newObject[sourceKey] = sourceValue;
          }
        }
        
        // If the target parent is the root knowledge base
        if (targetParentPath.length === 0) {
          // Replace the entire knowledge base
          Object.keys(knowledgeBase).forEach(key => {
            delete knowledgeBase[key];
          });
          Object.assign(knowledgeBase, newObject);
        } else {
          // Replace the target parent's properties
          Object.keys(targetParent).forEach(key => {
            delete targetParent[key];
          });
          Object.assign(targetParent, newObject);
        }
      }
    }
    
    updateUI();
    showToast("Item moved successfully!");
  } catch (error) {
    console.error("Error moving node:", error);
    showToast("Error moving item", "error");
  }
}
 
function addDragAndDropHelper() {
  // Create a visual helper element
  const helperElement = document.createElement('div');
  helperElement.className = 'drag-visual-helper';
  helperElement.innerHTML = `
    <strong>Drag & Drop Tips:</strong>
    <ul>
      <li>Drag items using the grip handle <i class="fas fa-grip-vertical"></i></li>
      <li>Drop position depends on where you drop:
        <ul>
          <li>Top area: Insert above</li>
          <li>Middle area: Insert inside</li>
          <li>Bottom area: Insert below</li>
        </ul>
      </li>
    </ul>
  `;
  
  // Add to the tree container
  treeContainer.appendChild(helperElement);
}
      // Function to move a node from one location to another
      function moveNode(sourcePath, targetPath) {
        try {
          // Get source and target values
          const sourceValue = getValueAtPath(knowledgeBase, sourcePath);
          const sourceKey = sourcePath[sourcePath.length - 1];
          const targetValue = getValueAtPath(knowledgeBase, targetPath);
          
          // Delete the source node
          deleteValueAtPath(knowledgeBase, sourcePath);
          
          // Determine target parent path and where to insert
          const targetParentPath = targetPath.slice(0, -1);
          const targetKey = targetPath[targetPath.length - 1];
          
          if (typeof targetValue === 'object' && targetValue !== null) {
            // Target is an object or array - insert as child
            if (Array.isArray(targetValue)) {
              targetValue.push(sourceValue);
            } else {
              // If inserting into an object, we need a key
              targetValue[sourceKey] = sourceValue;
            }
          } else {
            // Target is a simple value - insert as sibling
            const targetParent = targetParentPath.length > 0 
              ? getValueAtPath(knowledgeBase, targetParentPath) 
              : knowledgeBase;
            
            if (Array.isArray(targetParent)) {
              // For arrays, insert before the target
              const targetIndex = parseInt(targetKey);
              targetParent.splice(targetIndex, 0, sourceValue);
            } else {
              // For objects, just add a new property
              targetParent[sourceKey] = sourceValue;
            }
          }
          
          updateUI();
          showToast("Item moved successfully!");
        } catch (error) {
          console.error("Error moving node:", error);
          showToast("Error moving item", "error");
        }
      }
      
      function toggleNodeExpand(path) {
        const pathKey = path.join('.');
        expandedNodes[pathKey] = !expandedNodes[pathKey];
        updateUI();
      }
      
      function getValueAtPath(obj, path) {
        if (path.length === 0) return obj;
        
        let current = obj;
        for (let i = 0; i < path.length; i++) {
          if (current === undefined || current === null) return undefined;
          current = current[path[i]];
        }
        
        return current;
      }
      
      function setValueAtPath(obj, path, value) {
        if (path.length === 0) return value;
        
        const key = path[0];
        
        if (path.length === 1) {
          obj[key] = value;
          return obj;
        }
        
        if (obj[key] === undefined || obj[key] === null) {
          obj[key] = !isNaN(Number(path[1])) ? [] : {};
        }
        
        const remaining = path.slice(1);
        obj[key] = setValueAtPath(obj[key], remaining, value);
        return obj;
      }
      
      function deleteValueAtPath(obj, path) {
        if (path.length === 0) return;
        
        if (path.length === 1) {
          if (Array.isArray(obj)) {
            obj.splice(Number(path[0]), 1);
          } else {
            delete obj[path[0]];
          }
          return;
        }
        
        const key = path[0];
        const remaining = path.slice(1);
        
        if (obj[key] !== undefined && obj[key] !== null) {
          deleteValueAtPath(obj[key], remaining);
          
          // Clean up empty objects or arrays
          if (typeof obj[key] === 'object' && Object.keys(obj[key]).length === 0) {
            delete obj[key];
          }
        }
      }
      
      function deleteNode(path) {
        if (confirm(`Are you sure you want to delete "${path[path.length - 1]}"?`)) {
          if (path.length === 1) {
            delete knowledgeBase[path[0]];
          } else {
            const parentPath = path.slice(0, -1);
            const parent = getValueAtPath(knowledgeBase, parentPath);
            
            if (Array.isArray(parent)) {
              parent.splice(Number(path[path.length - 1]), 1);
            } else {
              delete parent[path[path.length - 1]];
            }
          }
          
          updateUI();
          showToast("Item deleted successfully!");
        }
      }
      
      // Edit modal functions
      function showEditModal(path) {
        editPath = path;
        editMode = 'edit';
        
        const value = getValueAtPath(knowledgeBase, path);
        const key = path.length > 0 ? path[path.length - 1] : '';
        
        // Set the key value
        editKey.value = key;
        
        // Key is always editable
        editKey.disabled = false;
        
        // Detect if value is rich text/HTML
        const isHtmlString = typeof value === 'string' && (
          value.startsWith('<') || 
          value.includes('</') || 
          value.includes('<p>') || 
          value.includes('<h')
        );
        
        if (isHtmlString) {
          // Set the value type to richtext
          editType.value = 'richtext';
          
          // Show rich text editor tab
          document.querySelector('[data-tab="rich-text"]').click();
          document.querySelector('.editor-tabs').style.display = 'flex';
          
          // Set content to both editors
          quillEditor.root.innerHTML = value;
          editValue.value = value;
        } else if (typeof value === 'object' && value !== null) {
          editValue.value = JSON.stringify(value, null, 2);
          editType.value = Array.isArray(value) ? 'array' : 'object';
          
          // Show raw text editor tab
          document.querySelector('[data-tab="raw-text"]').click();
          document.querySelector('.editor-tabs').style.display = 'none';
        } else {
          editValue.value = value === null ? '' : String(value);
          editType.value = typeof value;
          
          // For string values, show both editor options
          if (typeof value === 'string') {
            document.querySelector('.editor-tabs').style.display = 'flex';
            document.querySelector('[data-tab="raw-text"]').click();
            quillEditor.root.innerHTML = value;
          } else {
            document.querySelector('.editor-tabs').style.display = 'none';
          }
        }
        
        // Update modal title
        document.querySelector('.edit-title').textContent = 'Edit Value';
        editModal.classList.remove('hidden');
      }
      
      function showAddModal(path) {
        editPath = path;
        editMode = 'add';
        
        editKey.value = '';
        editKey.disabled = false;
        editValue.value = '';
        editType.value = 'string';
        
        // Reset rich text editor
        quillEditor.root.innerHTML = '';
        
        // Default to raw text view for new items
        document.querySelector('[data-tab="raw-text"]').click();
        document.querySelector('.editor-tabs').style.display = 'flex';
        
        // Check if parent is an array
        const parent = getValueAtPath(knowledgeBase, path);
        if (Array.isArray(parent)) {
          editKey.value = parent.length.toString();
          editKey.disabled = true;
        }
        
        // Update modal title
        document.querySelector('.edit-title').textContent = 'Add New Item';
        editModal.classList.remove('hidden');
      }
      
      function closeEditModal() {
        editModal.classList.add('hidden');
      }
      
      function saveEdit() {
        try {
          const key = editKey.value.trim();
          const type = editType.value;
          let value;
          
          if (editMode === 'add' && !key && !editKey.disabled) {
            alert('Property Name is required');
            return;
          }
          
          // Get value from the appropriate editor
          let editorContent;
          const activeTab = document.querySelector('.editor-tab.active').getAttribute('data-tab');
          
          if (activeTab === 'rich-text' && (type === 'string' || type === 'richtext')) {
            editorContent = quillEditor.root.innerHTML;
          } else {
            editorContent = editValue.value;
          }
          
          switch (type) {
            case 'string':
              value = editorContent;
              break;
            case 'richtext':
              value = editorContent; // Store as HTML string
              break;
            case 'number':
              value = Number(editorContent);
              if (isNaN(value)) throw new Error('Invalid number');
              break;
            case 'boolean':
              value = editorContent.toLowerCase() === 'true';
              break;
            case 'object':
            case 'array':
              try {
                value = JSON.parse(editorContent);
                if (type === 'array' && !Array.isArray(value)) {
                  value = Array.isArray(value) ? value : [];
                }
                if (type === 'object' && Array.isArray(value)) {
                  value = {};
                }
              } catch (e) {
                throw new Error('Invalid format: ' + e.message);
              }
              break;
          }
          
          if (editMode === 'edit') {
            if (editPath.length === 0) {
              knowledgeBase = value;
            } else {
              const parentPath = editPath.slice(0, -1);
              const parent = parentPath.length > 0 ? getValueAtPath(knowledgeBase, parentPath) : knowledgeBase;
              const oldKey = editPath[editPath.length - 1];
              
              // Delete the old key if the name has changed
              if (key !== oldKey) {
                if (Array.isArray(parent)) {
                  // For arrays, we need to replace at the same index
                  parent[parseInt(oldKey)] = value;
                } else {
                  // For objects, we remove the old property and add the new one
                  delete parent[oldKey];
                  parent[key] = value;
                }
              } else {
                // Key hasn't changed, just update the value
                parent[oldKey] = value;
              }
            }
            showToast("Item updated successfully!");
          } else if (editMode === 'add') {
            const parent = editPath.length > 0 ? getValueAtPath(knowledgeBase, editPath) : knowledgeBase;
            
            if (Array.isArray(parent)) {
              parent.push(value);
            } else {
              parent[key] = value;
            }
            
            // Auto-expand the parent node
            if (editPath.length > 0) {
              expandedNodes[editPath.join('.')] = true;
            }
            showToast("Item added successfully!");
          }
          
          closeEditModal();
          updateUI();
        } catch (error) {
          showToast(`Error: ${error.message}`, "error");
        }
      }
    });
  </script>
</body>
</html>
